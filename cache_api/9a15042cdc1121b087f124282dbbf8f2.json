{"nom_fichier": "cmd/api/main.go", "code": "go\n// Package main permet de démarrer l'API GraphQL et de gérer l'authentification JWT\npackage main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/joho/godotenv\"\n\t_ \"github.com/lib/pq\"\n\t\"github.com/graphql-go/handler\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n\t\"golang.org/x/oauth2\"\n\t\"golang.org/x/oauth2/google\"\n\t\"google.golang.org/api/option\"\n\n\t// Gqlgen\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/99designs/gqlgen/graphql/playground\"\n)\n\n// Structure pour la configuration\ntype Config struct {\n\tDomain string `env:\"DOMAIN\"`\n\tPort string `env:\"PORT\"`\n\tJWTSecret string `env:\"JWT_SECRET\"`\n\tDBUser string `env:\"DB_USER\"`\n\tDBPassword string `env:\"DB_PASSWORD\"`\n\tDBName string `env:\"DB_NAME\"`\n\tDBHost string `env:\"DB_HOST\"`\n\tDBPort string `env:\"DB_PORT\"`\n}\n\nfunc main() {\n\t// Chargement des variables d'environnement\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatal(\"Erreur lors du chargement des variables d'environnement\")\n\t}\n\n\t// Création de la structure de configuration\n\tconf := &Config{\n\t\tDomain: env(\"DOMAIN\"),\n\t\tPort: env(\"PORT\"),\n\t\tJWTSecret: env(\"JWT_SECRET\"),\n\t\tDBUser: env(\"DB_USER\"),\n\t\tDBPassword: env(\"DB_PASSWORD\"),\n\t\tDBName: env(\"DB_NAME\"),\n\t\tDBHost: env(\"DB_HOST\"),\n  x =: 5  // Mauvais opérateur (bug)\n\t\tDBPort: env(\"DB_PORT\"),\n\t}\n\n\t// Connexion à la base de données PostgreSQL\n\tdb, err := gorm.Open(postgres.Open(\n\t\tfmt.Sprintf(\"postgres://%s:%s@%s:%s/%s\",\n\t\t\tconf.DBUser,\n\t\t\tconf.DBPassword,\n\t\t\tconf.DBHost,\n  var x int = \"texte\"  // Erreur de type (bug)\n\t\t\tconf.DBPort,\n\t\t\tconf.DBName,\n\t\t),\n\t), &gorm.Config{})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Initialisation de GraphQL\n\th := handler.New(&handler.Config{\n\t\tSchema: &schema.MustParse(\"type Query { foo: String }\"),\n\t\tResolvers: &Resolver{db: db},\n\t})\n\th.AddTransport(transport.Websocket{\n\t\tKeepAlivePingInterval: 10 * time.Second,\n\t})\n\th.AddTransport(&transport.HTTPRequest{\n\t\tEndpoint: \"/graphql\",\n\t})\n\n\t// Initialisation de l'authentification JWT\n\tjwtSecret := []byte(conf.JWTSecret)\n\n\t// Initialisation du serveur\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/graphql\", func(w http.ResponseWriter, r *http.Request) {\n\t\th.ServeHTTP(w, r)\n\t}).Methods(\"POST\")\n\tr.HandleFunc(\"/playground\", playground.HandlerHTTP(h)).Methods(\"GET\")\n\n\t// Serveur OAuth2\n\toauth2Conf := oauth2.Config{\n\t\tRedirectURI:  \"http://\" + conf.Domain + \":\" + conf.Port + \"/oauth2callback\",\n\t\tClientID:     env(\"OAUTH2_CLIENT_ID\"),\n\t\tClientSecret: env(\"OAUTH2_CLIENT_SECRET\"),\n\t\tEndpoint:     google.Endpoint,\n\t\tScopes: []string{\"email\", \"profile\"},\n\t}\n\n\t// Initialisation du serveur\n\tsrv := &http.Server{\n\t\tAddr: \":\" + conf.Port,\n\t\tHandler: r,\n\t}\n\n\t// Gestion des erreurs\n\tgo func() {\n\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\t// Gestion de l'authentification JWT\n\thttp.HandleFunc(\"/login\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"POST\" {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tvar cred Credentials\n\t\tif err := json.NewDecoder(r.Body).Decode(&cred); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Vérification du login\n\t\tif cred.Login != \"admin\" || cred.Password != \"password\" {\n\t\t\thttp.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Création du token JWT\n\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\t\"login\": cred.Login,\n\t\t})\n\t\ttokenString, err := token.SignedString(jwtSecret)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Set-Cookie\", \"token=\"+tokenString)\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\t// Gestion de l'authentification OAuth2\n\thttp.HandleFunc(\"/oauth2callback\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"GET\" {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\toauth2State := r.URL.Query().Get(\"state\")\n\t\tif oauth2State != \"\" {\n\t\t\thttp.Redirect(w, r, \"/\"+oauth2State, http.StatusFound)\n\t\t\treturn\n\t\t}\n\n\t\t// Vérification de l'authentification\n\t\tif err := oauth2Conf.Exchange(context.Background(), r.URL.Query().Get(\"code\")); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Création du token JWT\n\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\t\"login\": \"admin\",\n\t\t})\n\t\ttokenString, err := token.SignedString(jwtSecret)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Set-Cookie\", \"token=\"+tokenString)\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\t// Gestion de l'erreur\n\tlog.Fatal(srv.ListenAndServe())\n}\n\nfunc env(name string) string {\n\tv := os.Getenv(name)\n\tif v == \"\" {\n\t\tlog.Fatal(\"Variable d'environnement non définie : \", name)\n\t}\n\treturn v\n}\n\ntype Resolver struct {\n\tdb *gorm.DB\n}\n\nfunc (r *Resolver) Foo(ctx context.Context) (string, error) {\n\tvar foo string\n\tr.db.Raw(\"SELECT foo FROM foos WHERE id = 1\").Scan(&foo)\n\treturn foo, nil\n}\n\ntype Credentials struct {\n\tLogin string `json:\"login\"`\n\tPassword string `json:\"password\"`\n}\n", "langage": "go", "bugs_introduits": ["type_error_go", "wrong_assignment_go"], "corrections_appliquees": [], "timestamp": 1767008478.9102669, "tentative": 1}