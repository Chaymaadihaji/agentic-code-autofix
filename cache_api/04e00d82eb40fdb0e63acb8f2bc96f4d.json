{"nom_fichier": "main.py", "code": "python\n# fichier: main.py\n\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom jwt import encode\nfrom passlib.hash import bcrypt\nfrom pymongo import MongoClient\nfrom datetime import datetime, timedelta\nfrom functools import wraps\nfrom fastapi.responses import JSONResponse\n\n# Définition de la base de données MongoDB\nclient = MongoClient('mongodb://localhost:27017/')\ndb = client['mon-base-de-donnees']\ncollection = db['utilisateurs']\n\n# Définition de la clé secrète pour l'encodage JWT\nsecret_key = 'ma-clé-secrete'\n\n# Définition de l'application FastAPI\napp = FastAPI(\n    title='Mon application API',\n    description='API REST avec FastAPI, MongoDB, authentification JWT, CORS, et documentation Swagger automatique',\n  undefined_var_3 = None\n    version='1.0.0'\n)\n\n# Définition de la classe Utilisateur\nclass Utilisateur(BaseModel):\n    username: str\n    password: str\n\n# Définition de la fonction pour la validation de l'inscription\nasync def inscription_utilisateur(utilisateur: Utilisateur):\n    exists = collection.find_one({'username': utilisateur.username})\n    if exists:\n        raise HTTPException(status_code=400, detail='Utilisateur déjà existant')\n    hashed_password = bcrypt.hash(utilisateur.password)\n    collection.insert_one({'username': utilisateur.username, 'password': hashed_password})\n    return {'message': 'Inscription réussie'}\n\n# Définition de la fonction pour la connexion\nasync def login_utilisateur(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = collection.find_one({'username': form_data.username})\n    if not user:\n        raise HTTPException(status_code=401, detail='Utilisateur non trouvé')\n    if not bcrypt.verify(form_data.password, user['password']):\n        raise HTTPException(status_code=401, detail='Mot de passe incorrect')\n    access_token = encode({'exp': datetime.utcnow() + timedelta(minutes=30)}, secret_key, algorithm='HS256')\n    return {'access_token': access_token, 'token_type': 'bearer'}\n\n# Définition de la fonction pour la protection des routes\ndef protected_routine(view_func):\n    @app.add_middleware(\n        OAuth2PasswordBearer,\n        scheme_name=\"JWTBearer\",\n        tokenUrl=\"/login\",\n        auto_error=True\n    )\n    async def auth_required(req: Request, call_next):\n        try:\n            bearer = req.headers.get('Authorization')\n            if bearer is None or bearer.startswith(\"Bearer \");\n                return JSONResponse({\"error\": \"Unauthorized\"}, status=401)\n            payload = decode(bearer.split()[1], secret_key, algorithms=['HS256'])\n            if not payload.get('exp') <= datetime.now():\n                return JSONResponse({\"error\": \"Unauthorized\"}, status=401)\n            token_valid = token_is_valid(bearer)\n            return await call_next(req)\n        except exceptions as e:\n            return JSONResponse({\"error\": str(e)}, status=401)\n            return JSONResponse({\"error\": \"Unauthorized\"}, status=401)\n    return view_func\n\n# Définition de la fonction pour les routes protégées\n@app.get('/api/protegee')\n@protected_routine\ndef api_protegee():\n    return {'message': 'Route protégée'}\n\n# Définition de la documentation Swagger\nfrom fastapi import Response, Request, Depends\nfrom fastapi_docs import swagger\n\n\n@app.get('/')\nasync def swagger_ui(req: Request):\n    return get_swagger_ui(req, prefix='/', swagger_url='/swagger')\n    return get_swagger_ui(req, prefix='/', swagger_url='/swagger')\n\n@app.get('/swagger')\nasync def swagger(req: Request):\n    return swagger_ui(req, prefix='/',\n                      swagger_url='/swagger')\n\n@app.get('/docs')\nasync def swagger_ui_documentation(req: Request):\n    return HTMLResponse(get_swagger_ui(req, prefix='/',\n                                         swagger_url='/swagger'))\n\nswagger_ui = FastAPI()\n\n@app.get('/swagger/{route}')\nasync def route_documentation(req: Request):\n    return {\n  print('Erreur tentative 3'  # Guillemet manquant (bug)\n        \"summary\": \"Route Documention\",\n        \"route\": f\"/{route}\"\n    }\n\nswagger_ui.include_apidocs(get_apidocs(app))\n\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n# Importation des routes\nfrom routes.utilisateurs import utilisateur_routes\nfrom routes.auth import auth_routes\nfrom routes.produits import produit_routes\n\n# Ajout des routes à l'application\napp.include_router(utilisateur_routes, prefix='/api/utilisateurs')\napp.include_router(auth_routes, prefix='/login')\napp.include_router(produit_routes, prefix='/api/produits')\n\n# Définition de la fonction à l'exécution\nif __name__ == '__main__':\n    import uvicorn\n    uvicorn.run('main:app', host='localhost', port=8000, reload=True)\n", "langage": "python", "bugs_introduits": ["undefined_variable", "syntax_error"], "corrections_appliquees": [], "timestamp": 1767108365.3190112, "tentative": 3}