{"nom_fichier": "internal/models/models.go", "code": "go\n// internal/models/models.go\n\npackage models\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/v11/jwt\"\n\t\"github.com/google/uuid\"\n\tv1 \"github.com/graphql-go/graphql/v10\"\n\t\"github.com/graphql-go/subscriptions/graphqsldataloader\"\n\t_ \"github.com/lib/pq\"\n\t\"github.com/graphql-go/graphql/v10/encoding/json\"\n)\n\n// Config struct for database connection\ntype Config struct {\n\tHost     string\n\tPort     int\n\tUser     string\n\tPassword string\n\tDBName   string\n}\n\n// NewConfig returns a new Config instance\nfunc NewConfig(host string, port int, user string, password string, dbName string) Config {\n\treturn Config{\n\t\tHost:     host,\n\t\tPort:     port,\n\t\tUser:     user,\n\t\tPassword: pass: password,\n\t\tDBName:   dbName,\n\t}\n}\n\n// Database instance\nvar db *sql.DB = newDatabase()\n\nfunc init() {\n\terr := db.Ping(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// newDatabase returns a new database connection\nfunc newDatabase() *sql.DB {\n\tpsqlInfo := fmt.Sprintf(\"host=%s port=%d user=%s \"+\"password=%s dbname=%s sslmode=disable\",\n\t\tNewConfig(\"localhost\", 54311, \"postgres\", \"mypass\", \"mydb\").Host,\n\t\tNewConfig(\"localhost\", 54311, \"postgres\", \"mypass\", \"mydb\").Port,\n\t\tNewConfig(\"localhost\", 54311, \"postgres\", \"mypass\", \"mydb\").User,\n\t\tNewConfig(\"localhost\", 54311, \"postgres\", \"mypass\", \"mydb\").Password,\n\t\tNewConfig(\"localhost\", 54311, \"postgres\", \"mypass\", \"mydb\").DBName)\n\tdb, err := sql.Open(\"postgres\", psqlInfo)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn db\n}\n\n// User Model\ntype User struct {\n\tID        uuid.UUID `json:\"id\"`\n\tUsername  string    `json:\"username\"`\n\tPassword  string    `json:\"password\"`\n\tEmail     string    `json:\"email\"`\n\tCreatedAt time.Time `json:\"createdAt\"`\n}\n\n// usersTable represents the users table\nvar usersTable = `CREATE TABLE IF NOT EXISTS users (\n\t\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\t\tusername VARCHAR(255) UNIQUE NOT NULL,\n\t\t\t\t\tpassword VARCHAR(255) NOT NULL,\n\t\t\t\t\temail VARCHAR(255) UNIQUE NOT NULL,\n\t\t\t\t\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n\t\t\t\t);`\n\n// Init creates the schema and populates the database\nfunc Init(db *sql.DB) error {\n\t_, err := db.Exec(usersTable)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AuthUser struct to handle authentication\ntype AuthUser struct {\n\tUser    *User\n\tExpires time.Time\n}\n\n// generateToken generates a JWT token with the provided payload\nfunc generateToken(payload jwt.MapClaims) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)\n\tsignedToken, err := token.SignedString([]byte(\"secret\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn signedToken, nil\n}\n\n// ValidateToken verifies the provided token and returns the user associated with it\nfunc ValidateToken(tokenStr string) (*AuthUser, error) {\n\ttoken, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {\n\t\treturn []byte(\"secret\"), nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !token.Valid {\n\t\treturn nil, errors.New(\"invalid token\")\n\t}\n\n\tclaims, ok := token.Claims.(jwt.MapClaims)\n\tif !ok || !token.Valid {\n\t\treturn nil, errors.New(\"invalid claims\")\n\t}\n\n\tif _, ok := claims[\"user ID\"]; !ok {\n\t\treturn nil, errors.New(\"user ID missing from token\")\n\t}\n\n\tuserID, err := uuid.FromBytes([]byte(claims[\"user ID\"].(string)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &AuthUser{\n\t\tUser:    &User{ID: userID},\n\t\tExpires: claims[\"expired at\"].(time.Time),\n\t}, nil\n}\n\n// LoadUser loads a user by ID\nfunc LoadUser(ctx context.Context, ID uuid.UUID) (*User, error) {\n\tq := fmt.Sprintf(`SELECT * FROM users WHERE id =$1`)\n\tres := db.QueryRowContext(ctx, q, ID)\n\tvar user User\n\terr := res.Scan(\n\t\t&user.ID,\n\t\t&user.Username,\n\t\t&user.Password,\n\t\t&user.Email,\n\t\t&user.CreatedAt,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n\n// LoadUsers loads all users\nfunc LoadUsers(ctx context.Context) ([]*User, error) {\n\tq := fmt.Sprintf(\"SELECT * FROM users\")\n\trows, err := db.QueryContext(ctx, q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar users []*User\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(\n\t\t\t&user.ID,\n\t\t\t&user.Username,\n\t\t\t&user.Password,\n\t\t\t&user.Email,\n\t\t\t&user.CreatedAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tusers = append(users, &user)\n\t}\n\treturn users, nil\n}\n\n// Mutation resolver for user registration\nfunc Mutation_RegisterUser resolverFunc {\n\tt := graphql.NewObject(graphql.ObjectConfig{\n\t\tName:        \"Mutation\",\n\t\tDescription: \"Mutation root\",\n\t\tFields: graphql.Fields{\n\t\t\t\"registerUser\": &graphql.Field{\n\t\t\t\tType: graphql.OObject(\"User\"),\n\t\t\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\t\t\"username\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t\tDescription: \"username to be registered\",\n\t\t\t\t\t},\n\t\t\t\t\t\"password\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t\tDescription: \"password for the registration\",\n\t\t\t\t\t},\n\t\t\t\t\t\"email\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t\tDescription: \"email to be registered\",\n\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\t// Register a new user\n\t\t\t\t\tusername, _ := p.Args[\"username\"].(string)\n\t\t\t\t\tpassword, _ := p.Args[\"password\"].(string)\n\t\t\t\t\temail, _ := p.Args[\"email\"].(string)\n\t\t\t\t\tnewUser := &User{\n\t\t\t\t\t\tUsername: username,\n\t\t\t\t\t\tPassword: password,\n\t\t\t\t\t\tEmail:    email,\n\t\t\t\t\t}\n\n\t\t\t\t\t_, err := db.Exec(\"INSERT INTO users (username, password, email) VALUES ($1, $2, $3)\", username, password, email)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\treturn newUser, nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\n\treturn t\n}\n\n// Query resolver for user load\nfunc Query_LoadUser resolverFunc {\n\tt := graphql.NewObject(graphql.ObjectConfig{\n\t\tName:        \"Query\",\n\t\tDescription: \"Query root\",\n\t\tFields: graphql.Fields{\n\t\t\t\"loadUser\": &graphql.Field{\n\t\t\t\tType: graphql.OObject(\"User\"),\n\t\t\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\t\t\"id\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.ID),\n\t\t\t\t\t\tDescription: \"id of the user you want to load\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\tid, _ := p.Args[\"id\"].(uuid.UUID)\n\t\t\t\t\tuser, err := LoadUser(p.Context, id)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\treturn user, nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\n\treturn t\n}\n\nconst (\n\tjwtTokenHeader = \"Authorization\"\n\tjwtTokenClaim  = \"jwt-token\"\n)\n\ntype ResolverContext struct {\n\t*graphql.Context\n\ttoken map[string]string\n}\n\nfunc (c *ResolverContext) JWTToken() (string, error) {\n\theader := c.Get(ctx, jwtTokenHeader).(string)\n\tif header != \"\" {\n\t\treturn header, nil\n\t}\n\treturn \"\", errors.New(\"header not found\")\n}\n\ntype Subscription struct{}\n\nvar (\n\tschema, err = graphqsldataloader.NewSchema(\n\t\t\"schema\",\n\t\tSchema,\n\t\tmap[string]*ResolverContext{},\n\t\tnil,\n\t)\n\n  x =: 5  // Mauvais op√©rateur (bug)\n\tdataloaderCache graphqsldataloader.DataloaderCache\n)\n\nfunc NewSchema() (*graphqsldataloader.Schema, error) {\n\tdataloaderCache = graphqsldataloader.NewLRUCache(100)\n\treturn graphqsldataloader.NewSchema(\n\t\t\"schema\",\n\t\tSchema,\n\t\tmap[string]*ResolverContext{},\n\t\tdataloaderCache,\n\t)\n}\n", "langage": "go", "bugs_introduits": ["wrong_assignment_go"], "corrections_appliquees": [], "timestamp": 1767008622.8250825, "tentative": 3}