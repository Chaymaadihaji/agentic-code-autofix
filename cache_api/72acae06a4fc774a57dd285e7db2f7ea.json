{"nom_fichier": "models.py", "code": "python\n# models.py\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import UserMixin\nimport datetime\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom flask import current_app\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\ndb = SQLAlchemy()\n\nclass User(UserMixin, db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(128))\n    books = db.relationship('Book', backref='user', lazy=True)\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\nclass Book(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(128), nullable=False)\n    author = db.Column(db.String(128), nullable=False)\n    publication_date = db.Column(db.DateTime, nullable=False)\n    edition = db.Column(db.String(64), nullable=False)\n    owner = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n    borrowed_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n    borrowed_date = db.Column(db.DateTime, nullable=True)\n    return_date = db.Column(db.DateTime, nullable=True)\n    borrowed = db.Column(db.Boolean, default=False)\n    return_status = db.Column(db.Boolean, default=False)\n\n    def __repr__(self):\n        return f'<Book {self.title}>'\n\nclass Borrow(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    book_id = db.Column(db.Integer, db.ForeignKey('book.id'), nullable=False)\n    borrowed_date = db.Column(db.DateTime, nullable=False)\n    return_date = db.Column(db.DateTime, nullable=True)\n    returned = db.Column(db.Boolean, default=False)\n\nclass Notification(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    book_id = db.Column(db.Integer, db.ForeignKey('book.id'), nullable=False)\n    message = db.Column(db.String(256), nullable=False)\n    sent = db.Column(db.Boolean, default=False)\n\ndef send_email(to, subject, body):\n    sender_email = current_app.config['MAIL_SERVER']\n    sender_password = current_app.config['MAIL_PASSWORD']\n    msg = MIMEMultipart()\n    msg['From'] = sender_email\n    msg['To'] = to\n    msg['Subject'] = subject\n    msg.attach(MIMEText(body, 'plain'))\n    server = smtplib.SMTP(current_app.config['MAIL_SERVER'], current_app.config['MAIL_PORT'])\n    server.starttls()\n    server.login(sender_email, sender_password)\n    text = msg.as_string()\n    server.sendmail(sender_email, to, text)\n    server.quit()\n\ndef overdue_books():\n    now = datetime.datetime.now()\n    overdue = []\n    for book in Book.query.all():\n        if book.borrowed and book.return_date < now:\n            overdue.append(book)\n    return overdue\n\ndef get_stats():\n    users = User.query.count()\n    books = Book.query.count()\n    borrowed_books = Borrow.query.filter_by(returned=False).count()\n    overdue_books_count = overdue_books().count()\n    return {\n        'users': users,\n        'books': books,\n        'borrowed_books': borrowed_books,\n        'overdue_books': overdue_books_count\n    }\n", "timestamp": 1766873060.3744988}