{"nom_fichier": "main.go", "code": "```go\n// main.go\npackage main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/google/uuid\"\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/graphql-go/graphql/gqlerrors\"\n\t\"github.com/graphql-go/interop\"\n\t\"github.com/graphql-go/subscriptions\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/lib/pq\"\n\t\"github.com/mitchellh/mapstructure\"\n\t\"github.com/volatiletech/sqlboiler/v4/boil\"\n\t\"github.com/volatiletech/sqlboiler/v4/postgresql\"\n\n\t\"gqlgen/graphql-go/internal/graphql/subscription\"\n)\n\nvar (\n\tserver       = echo.New()\n\tdbConnection  = sql.OpenDB(pq.ConnPoolConfig{\n\t\tMaxConnections: 10,\n\t\tTLS: nil,\n\t})\n\tjwtKey = \"secretKey\"\n}\n\ntype User struct{\n    Id string `sqlboil:\"id\"`\n    Username string `sqlboil:\"username\"`\n    Email string  `sqlboil:\"email\"`\n}\n\nfunc main() {\n\t// Set up database connection\n\terr := postgresql.DBInit(dbConnection, \"user=myuser dbname=mydb password=mypassword host=localhost sslmode=disable\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Set up JWT secret key\n\tconst claimsKey = \"exp\" // JWT Key\n\n\t// Setup JWT Secret Key, this should go in an environment variable for production\n\tjwtSecretKey := jwtKey\n\n\t// Set up GraphQL scheme\n\tschema, err := graphql.NewSchema(graphql.SchemaConfig{\n\t\tQuery: graphQLQuery,\n\t\tMutation: map[string]graphql.Field{\n\t\t\t\"login\": graphQLLogin,\n\t\t},\n\t\tSubscription: graphql.Subscription{\n\t\t\tOnConnect:   graphQLConnect,\n\t\t\tOnDisconnect: func(ctx context.Context, message interface{}) {\n\t\t\t\tlog.Println(message)\n\t\t\t},\n\t\t},\n\t\tMutations: map[string]graphql.Field{\n\t\t\t\"createUser\": createUser,\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Set up GraphQL handler\n\tgraphQLHandler := echo.NewMultipartHandler()\n\tgraphQLHandler.GraphQLSchema = schema\n\tgraphQLHandler.Middleware(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\ttokenString, err := c.Get(\"token\")\n\t\t\tif err != nil {\n\t\t\t\treturn c.String(http.StatusBadRequest, err.Error())\n\t\t\t}\n\t\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (valid bool, msg string) {\n\t\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\t\treturn false, \"Unexpected signing method\"\n\t\t\t\t}\n\t\t\t\treturn true, \"\"\n\t\t\t})\n\t\t\tif err != nil || !token.Valid {\n\t\t\t\treturn c.String(http.StatusUnauthorized, \"Unauthorized\")\n\t\t\t}\n\t\t\tclaims := new(JWTClaims)\n\t\t\terr = mapstructure.Decode(token.Claims, claims)\n\t\t\tif err != nil {\n\t\t\t\treturn c.String(http.StatusInternalServerError, err.Error())\n\t\t\t}\n\t\t\tc.Set(\"user\", claims.ID)\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\t// Set up WebSocket handler\n\tws := echo.NewWebSocketHandler()\n\tws.OnConnect = func(s *websocket.Conn) {\n\t\tfmt.Println(\"onConnect called\")\n\t}\n\tws.OnDisconnect = func(s *websocket.Conn) {\n\t\tfmt.Println(\"onDisconnect called\")\n\t}\n\n\t// Set up routes\n\tserver.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, \"Hello, World!\")\n\t})\n\tserver.POST(\"/graphql\", graphQLHandler)\n\tserver.POST(\"/ws\", ws.Handler)\n\n\t// Set up JWT handler\n\tjwtHandler := func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\ttokenString, err := c.Get(\"token\")\n\t\t\tif err != nil {\n\t\t\t\treturn echo.ErrUnauthorized\n\t\t\t}\n\t\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (valid bool, msg string) {\n\t\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\t\treturn false, \"Unexpected signing method\"\n\t\t\t\t}\n\t\t\t\treturn true, \"\"\n\t\t\t})\n\t\t\tif err != nil || !token.Valid {\n\t\t\t\treturn echo.ErrUnauthorized\n\t\t\t}\n\t\t\tclaims := new(JWTClaims)\n\t\t\terr = mapstructure.Decode(token.Claims, claims)\n\t\t\tif err != nil {\n\t\t\t\treturn echo.ErrInternalServerError\n\t\t\t}\n\t\t\tc.Set(\"user\", claims.ID)\n\t\t\treturn next(c)\n\t\t}\n\t}\n\n\t// Set up auth routes\n\tserver.POST(\"/auth/register\", auth.Register)\n\tserver.POST(\"/auth/login\", auth.Login)\n\n\t// Set up user routes\n\tserver.GET(\"/users\", getAllUsers)\n\tserver.GET(\"/user/:id\", getUser)\n\tserver.POST(\"/users\", createUser)\n\n\t// Set up message routes\n\tserver.GET(\"/message/:id\", GetMessage)\n\tserver.GET(\"/messages\", GetAllMessages)\n\tserver.POST(\"/messages\", SendMessage)\n\n\t// Set up WebSocket routes\n\tserver.GET(\"/subscribe\", Subscribe)\n\tserver.GET(\"/subscribe/:id\", SubscribeID)\n\n\t// Set up GraphQL routes\n\tgraphQLHandler.GraphQLRoute = \"/graphql\"\n\n\t// Set up JWT middleware\n\tmiddleware.JWTWithConfig(middleware.JWTConfig{\n\t\tSigningKey:     []byte(jwtSecretKey),\n\t\tSigningMethod:  jwt.SigningMethodHS256,\n\t\tClaims       : map[string]interface{}{\"id\": \"\", \"username\": \"\"},\n\t})\n\n\tserver.Use(jwtHandler())\n\n\t// Set up database connection\n\tgo func() {\n\t  err := postgresql.Listen(\"localhost:9000\")\n\t    if err != nil {\n\t      log.Println(err)\n\t    }\n\t}()\n\n\terr := server.Start(\":8000\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc graphQLConnect(ws *echo.Websocket) echo.Msg {\n\tfmt.Println(\"onConnect called\")\n\n\treturn echo.Msg{}\n}\n\nfunc Subscribe(conn *echo.Websocket, c echo.Context) error {\n\tfmt.Println(\"onSubscribe called\")\n\n\tconn.Broadcast <- echo.Message{\n\t\tType:      \"NEW_MESSAGE\",\n\t\tPayload:   \"Message\",\n\t}\n\n\treturn nil\n}\n\nfunc SubscribeID(c echo.Context) error {\n\tfmt.Println(\"onSubscribeID called\")\n\n\treturn nil\n}\n\nfunc graphQLQuery(_ context.Context, args map[string]interface{}) (interface{}, error) {\n\tauthorId := args[\"id\"].(string)\n\n\tauthor := User{}\n\tif err := UserGQl.Where(\"id=?\", authorId). Bind(&author).Get(); err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, gqlerrors.Errorf(\"Author not found with id = %q\", authorId)\n\t\t}\n\t\treturn nil, gqlerrors.Errorf(\"Failed to load user with id = %s from database\", authorId)\n\t}\n\n\treturn &UserGraphQLResponse{\n\t\tAuthor: &author,\n\t}, nil\n}\n\nfunc graphQLLogin(context context.Context, args map[string]interface{}) (interface{}, error) {\n\tuser := &User{}\n\terr := Mapstructure.Unmarshal(args, user)\n\tif err != nil {\n\t\treturn nil, gqlerrors.Errorf(err.Error())\n\t}\n\n\tif err = user.Validate(); err != nil {\n\t\treturn nil, gqlerrors.Errorf(err.Error())\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"id\": user.ID,\n\t\t\"username\": user.Username,\n\t})\n\ttokenString, err := token.SignedString([]byte(jwtKey))\n\tif err != nil {\n\t\treturn nil, gqlerrors.Errorf(err.Error())\n\t}\n\n\treturn struct {\n\t\tToken       string `json:\"token\"`\n\t\tUser        map[string]interface{} `json:\"user\"`\n\t}{Token: tokenString,\n\t\tUser: map[string]interface{}{\n\t\t\t\"id\": user.ID,\n\t\t\t\"username\": user.Username,\n\t\t},\n\t}, nil\n}\n\ntype UserGraphQLResponse struct {\n\tAuthor *User\n}\n\nfunc (m *UserGraphQLResponse) marshalJSON(w io.Writer, fields []string, ctx context.Context) error {\n\tgraphqlTypes := graphql.MarshalGraphql(m, fields, ctx)\n\tfmt.Fprint(w, graphqlTypes)\n\treturn nil\n}\n\nfunc (m *UserGraphQLResponse) validate(ctx context.Context) (*schema.ValidationError, error) {\n\treturn nil, nil\n}\n\n// GQLgen model generated by\n// boilerplate\ntype UserBoil struct {\n\t*boil.Model\n\t*boil.TimestampsModel\n}\n\nfunc (m UserBoil) TableName() string {\n\treturn \"user\"\n}\n\nfunc (m UserBoil) Fields() (string, [][]string) {\n\treturn `id, username, timestamp_create, timestamp_update`, []string{}\n}\n\nfunc (m UserBoil) FieldsGql() (string, [][]string) {\n\treturn `username, timestamp_create, timestamp_update, id `, []string{}\n}\n\ntype UserGQl struct {\n\t*boil.Model\n\t*boil.TimestampsModel\n}\n\nfunc (m UserGQl) TableName() string {\n\treturn \"user\"\n}\n\nfunc (m UserGQl) Fields() (string, [][]string) {\n\treturn `id, username, timestamp_create, timestamp_update`, []string{}\n}\n\nfunc (m UserGQl) FieldsGql() (string, [][]string) {\n\treturn `username, timestamp_create, timestamp_update, id `, []string{}\n}\n\n// Model for\n// graphql\ntype UserGraphQL struct {\n", "bugs_introduits": [], "timestamp": 1767006931.4357703}