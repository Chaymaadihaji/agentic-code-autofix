{"nom_fichier": "main.py", "code": "**main.py**\n```python\nfrom flask import Flask, request, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_marshmallow import Marshmallow\nfrom flask_jwt_extended import JWTManager, jwt_required, create_access_token, get_jwt_identity\nfrom flask_mail import Mail, Message\nfrom flask_restful import Api\nfrom flask_bcrypt import Bcrypt\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom flask_cors import CORS\nimport logging\nimport os\nimport csv\nfrom datetime import datetime, timedelta\nfrom io import BytesIO\nfrom xhtml2pdf import pisa\nfrom flask_uploads import configure_uploads, UploadSet, IMAGES\nfrom flask_user import UserMixin, SQLAlchemyMixin\nfrom functools import wraps\n\napp = Flask(__name__)\napp.config.from_object('config.Config')\n\ndb = SQLAlchemy(app)\nma = Marshmallow(app)\njwt = JWTManager(app)\nbcrypt = Bcrypt(app)\nmail = Mail(app)\napi = Api(app)\ncors = CORS(app)\n\n# Configuration de la base de données\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bibliotheque.db'\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\n# Configuration de l'authentification\napp.config['JWT_SECRET_KEY'] = 'secret_key_here'\napp.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=1)\n\n# Configuration du mail\napp.config['MAIL_SERVER'] = 'smtp.gmail.com'\napp.config['MAIL_PORT'] = 587\napp.config['MAIL_USE_TLS'] = True\napp.config['MAIL_USERNAME'] = 'your_email@gmail.com'\napp.config['MAIL_PASSWORD'] = 'your_password'\n\n# Configuration de l'upload de fichiers\nphotos = UploadSet('photos', IMAGES)\n\n# Configuration de la base de données\nclass User(UserMixin, db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password = db.Column(db.String(128), nullable=False)\n\nclass Book(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(120), nullable=False)\n    author = db.Column(db.String(120), nullable=False)\n    date = db.Column(db.Date, nullable=False)\n    returned = db.Column(db.Boolean, default=False)\n\nclass Borrow(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    book_id = db.Column(db.Integer, db.ForeignKey('book.id'), nullable=False)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    borrowed_date = db.Column(db.Date, nullable=False)\n    return_date = db.Column(db.Date, nullable=False)\n\n# Configuration de la marshmallow\nclass BookSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = Book\n\nclass UserSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = User\n\nclass BorrowSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = Borrow\n\n# Configuration de la route de connexion\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.json['username']\n    password = request.json['password']\n    user = User.query.filter_by(username=username).first()\n    if user and bcrypt.check_password_hash(user.password, password):\n        access_token = create_access_token(identity=username)\n        return jsonify(access_token=access_token)\n    return jsonify({'error': 'invalid credentials'}), 401\n\n# Configuration de la route d'inscription\n@app.route('/register', methods=['POST'])\ndef register():\n    username = request.json['username']\n    email = request.json['email']\n    password = bcrypt.generate_password_hash(request.json['password']).decode('utf-8')\n    user = User(username=username, email=email, password=password)\n    db.session.add(user)\n    db.session.commit()\n    return jsonify({'message': 'user created successfully'})\n\n# Configuration de la route de déconnexion\n@app.route('/logout', methods=['POST'])\n@jwt_required\ndef logout():\n    return jsonify({'message': 'user logged out successfully'})\n\n# Configuration de la route d'ajout de livre\n@app.route('/add_book', methods=['POST'])\n@jwt_required\ndef add_book():\n    title = request.json['title']\n    author = request.json['author']\n    date = datetime.strptime(request.json['date'], '%Y-%m-%d').date()\n    book = Book(title=title, author=author, date=date)\n    db.session.add(book)\n    db.session.commit()\n    return jsonify({'message': 'book added successfully'})\n\n# Configuration de la route de modification de livre\n@app.route('/modify_book', methods=['POST'])\n@jwt_required\ndef modify_book():\n    id = request.json['id']\n    title = request.json['title']\n    author = request.json['author']\n    date = datetime.strptime(request.json['date'], '%Y-%m-%d').date()\n    book = Book.query.get(id)\n    if book:\n        book.title = title\n        book.author = author\n        book.date = date\n        db.session.commit()\n        return jsonify({'message': 'book modified successfully'})\n    return jsonify({'error': 'book not found'}), 404\n\n# Configuration de la route de suppression de livre\n@app.route('/delete_book', methods=['POST'])\n@jwt_required\ndef delete_book():\n    id = request.json['id']\n    book = Book.query.get(id)\n    if book:\n        db.session.delete(book)\n        db.session.commit()\n        return jsonify({'message': 'book deleted successfully'})\n    return jsonify({'error': 'book not found'}), 404\n\n# Configuration de la route de recherche de livre\n@app.route('/search_book', methods=['POST'])\ndef search_book():\n    query = request.json['query']\n    books = Book.query.filter(Book.title.like('%' + query + '%')).all()\n    return jsonify([BookSchema().dump(book) for book in books])\n\n# Configuration de la route d'emprunt de livre\n@app.route('/borrow_book', methods=['POST'])\n@jwt_required\ndef borrow_book():\n    id = request.json['id']\n    book = Book.query.get(id)\n    if book and not book.returned:\n        borrowed_date = datetime.now().date()\n        return_date = borrowed_date + timedelta(days=14)\n        borrow = Borrow(book_id=id, user_id=get_jwt_identity(), borrowed_date=borrowed_date, return_date=return_date)\n        db.session.add(borrow)\n        db.session.commit()\n        return jsonify({'message': 'book borrowed successfully'})\n    return jsonify({'error': 'book not found or already borrowed'}), 404\n\n# Configuration de la route de retour de livre\n@app.route('/return_book', methods=['POST'])\n@jwt_required\ndef return_book():\n    id = request.json['id']\n    borrow = Borrow.query.get(id)\n    if borrow:\n        book = Book.query.get(borrow.book_id)\n        book.returned = True\n        db.session.commit()\n        return jsonify({'message': 'book returned successfully'})\n    return jsonify({'error': 'borrow not found'}), 404\n\n# Configuration de la route de notification de retard\n@app.route('/notification', methods=['POST'])\ndef notification():\n    # Faire la notification par email\n    return jsonify({'message': 'notification sent successfully'})\n\n# Configuration de la route de dashboard administrateur\n@app.route('/dashboard', methods=['GET'])\n@jwt_required\ndef dashboard():\n    # Afficher les statistiques\n    return jsonify({'message': 'dashboard displayed successfully'})\n\n# Configuration de la route de l'API REST\nclass BookResource(Resource):\n    @jwt_required\n    def get(self, id):\n        book = Book.query.get(id)\n        if book:\n            return jsonify(BookSchema().dump(book))\n        return jsonify({'error': 'book not found'}), 404\n\n    def put(self, id):\n        # Mettre à jour le livre\n        return jsonify({'message': 'book updated successfully'})\n\n    def delete(self, id):\n        # Supprimer le livre\n        return jsonify({'message': 'book deleted successfully'})\n\nclass BorrowResource(Resource):\n    @jwt_required\n    def get(self, id):\n        borrow = Borrow.query.get(id)\n        if borrow:\n            return jsonify(BorrowSchema().dump(borrow))\n        return jsonify({'error': 'borrow not found'}), 404\n\n    def put(self, id):\n        # Mettre à jour l'emprunt\n        return jsonify({'message': 'borrow updated successfully'})\n\n    def delete(self, id):\n        # Supprimer l'emprunt\n        return jsonify({'message': 'borrow deleted successfully'})\n\napi.add_resource(BookResource, '/book/<int:id>')\napi.add_resource(BorrowResource, '/borrow/<int:id>')\n\n# Configuration de la route de test\n@app.route('/test', methods=['GET'])\ndef test():\n    return jsonify({'message': 'test successful'})\n\n# Configuration de la route de documentation\n@app.route('/docs', methods=['GET'])\ndef docs():\n    return jsonify({'message': 'docs displayed successfully'})\n\n# Configuration de la route de déploiement\n@app.route('/deploy', methods=['GET'])\ndef deploy():\n    return jsonify({'message': 'deployment successful'})\n\n# Configuration de l'export des données en CSV\n@app.route('/export_csv', methods=['GET'])\ndef export_csv():\n    books = Book.query.all()\n    output = BytesIO()\n    writer = csv.writer(output)\n    writer.writerow(['Title', 'Author', 'Date'])\n    for book in books:\n        writer.writerow([book.title, book.author, book.date])\n   \n", "timestamp": 1766872943.704061}