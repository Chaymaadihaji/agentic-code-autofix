{"nom_fichier": "main.go", "code": "go\n// main.go\n\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/graph-gophers/golang-gqlgen/graphql/handler\"\n\t\"github.com/graph-gophers/golang-gqlgen/graphql/handler/extension\"\n\t\"github.com/graph-gophers/golang-gqlgen/graphql/playground\"\n\t\"github.com/joho/godotenv\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/lib/pq\"\n\t\"github.com/neo4j/neo4j-go-driver/v5/neo4j\"\n)\n\nvar err error\n\nconst port = \"8080\"\nconst jwtSecret = \"jwtsecret\"\nconst dbUser = \"postgres\"\nconst dbPassword = \"password\"\nconst dbHost = \"localhost\"\nconst dbPort = \"5432\"\nconst dbName = \"database\"\n\nfunc init() {\n\t// Load .env\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Get environment variables\n\tjwtSecret = os.Getenv(\"JWT_SECRET\")\n\tdbUser = os.Getenv(\"DB_USER\")\n\tdbPassword = os.Getenv(\"DB_PASSWORD\")\n\tdbHost = os.Getenv(\"DB_HOST\")\n\tdbPort = os.Getenv(\"DB_PORT\")\n\tdbName = os.Getenv(\"DB_NAME\")\n}\n\ntype Resolver struct{}\n\nfunc (r *Resolver) Mutation() MutationResolver {\n\treturn &mutationResolver{r}\n}\n\nfunc (r *Resolver) Query() QueryResolver {\n\treturn &queryResolver{r}\n}\n\nfunc (r *Resolver) Subscription() SubscriptionResolver {\n\treturn &subscriptionResolver{r}\n}\n\nfunc runDatabaseSchema() {\n\tpg := fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s\",\n\t\tdbHost, dbPort, dbUser, dbPassword, dbName,\n\t)\n\n\t_, err := pq.ParseConfig(pg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc main() {\n\t// Gqlgen\n\tmgr := NewGQLOperationManager()\n\n\ttypeQuery, err := LoadSchema(&Resolver{})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tcfg := handler.Config{\n\t\tSchema:                    typeQuery,\n\t\tPrefetch:                   true,\n\t\tAutoCompletions:            nil,\n\t\tDisableIntroscription:      false,\n\t\tPlayground:                 playground.Config{GraphQLAPI: &playground.API{Title: \"GraphQL API\"}},\n\t\tExtensions:                 []extension.Extension{extension.Introspection, graphqlDebugging},\n\t\tMiddleware:                 nil,\n\t\tDisableErrorpplications:    false,\n\t}\n\n\ts := handler.New(cfg)\n\n\ttypeGraphQL = *typeQuery.Schema().(*graph.graphSchema)\n\n\ts.AddInterceptor(func(next handler.FieldInterceptor) handler.FieldInterceptor {\n\t\treturn func(ctx context.Context, fn handler.FieldResolveF) (interface{}, error) {\n\t\t\t// Do something before resolving the field\n\t\t\treturn fn(ctx)\n\t\t}\n\t})\n\n\t// Base de donn√©es\n\trunDatabaseSchema()\n\n\t// Echo\n\te := echo.New()\n\n\tgreeting := func(c echo.Context) error {\n\t\tname := c.Param(\"name\")\n\t\treturn c.String(http.StatusOK, \"Hello, \"+name+\"!\")\n\t}\n\n\t// Authentication\n\te.Use(authJWT())\n\te.Use(middleware.CORS())\n\te.GET(\"/graphql\", graphqlHandler(s))\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello World - API GraphQL avec JWT\")\n\t})\n\n\tif err := e.Start(\":\" + port); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n", "langage": "go", "bugs_introduits": [], "corrections_appliquees": [], "timestamp": 1767008637.5993114, "tentative": 4}