{"nom_fichier": "internal/models/models.go", "code": "go\n// internal/models/models.go\n\npackage models\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/gorilla/sessions\"\n\t\"golang.org/x/crypto/bcrypt\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n)\n\n// User structure representing a User entity\ntype User struct {\n\tgorm.Model\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n\tRole     string `json:\"role\"`\n}\n\n// Product structure representing a Product entity\ntype Product struct {\n\tgorm.Model\n\tName      string `json:\"name\"`\n\tPrice     float64 `json:\"price\"`\n\tStock     int     `json:\"stock\"`\n\tUsername  string `json:\"username\"`\n}\n\n// LoginInput structure representing Login input data\ntype LoginInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\n// RegisterInput structure representing Register input data\ntype RegisterInput struct {\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n}\n\n// Token structure representing Token\ntype Token struct {\n\tAccess  string `json:\"access\"`\n\tRefresh string `json:\"refresh\"`\n}\n\n// JWTStore is a gorilla sessions store using JWT\nfunc JWTStore(s *sessions.Manager) (sessions.Store, error) {\n\treturn sessions.NewCookieStore([]byte(uuid.NewString())), nil\n}\n\n// CreateToken creates a new JWT token\nfunc CreateToken(access *string, refresh *string) (*Token, error) {\n\treturn &Token{AccessToken: access, RefreshToken: refresh}, nil\n}\n\nfunc hashAndSalt(pwd string) (string, error) {\n\thashedPws, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\", err\n\t}\n\n\treturn string(hashedPws), nil\n}\n\n// ValidatePassword function to compare a given password\nfunc ValidatePassword(providedPwd string, storedPWD []byte) error {\n\treturn bcrypt.CompareHashAndPassword(storedPWD, []byte(providedPwd))\n}\n\n  x =: 5  // Mauvais op√©rateur (bug)\nfunc connectDB() (*gorm.DB, error) {\n\tdsn := \"host=localhost user=postgres dbname=postgres port=5432 password=postgres sslmode=disable\"\n\tdb, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc createSchema(db *gorm.DB) error {\n\tif db.Migrator().HasTable(\"users\") {\n\t\treturn nil\n\t}\n\n\tdb.AutoMigrate(&User{})\n\tdb.AutoMigrate(&Product{})\n\n\treturn nil\n}\n\nfunc findUserByUsername(db *gorm.DB, username string) (*User, error) {\n\tvar user User\n\tresult := db.Where(\"username = ?\", username).First(&user)\n\n\tif result.Error != nil {\n\t\tif errors.Is(result.Error, pq.ErrNoRows) {\n\t\t\treturn nil, errors.New(\"user not found\")\n\t\t} else {\n\t\t\treturn nil, result.Error\n\t\t}\n\t}\n\n\treturn &user, nil\n}\n\nfunc loginUser(db *gorm.DB, input *LoginInput) (*User, *Token, error) {\n\tuser, err := findUserByUsername(db, input.Username)\n\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\terr = ValidatePassword(input.Password, []byte(user.Password))\n\n\tif err != nil {\n\t\treturn nil, nil, errors.New(\"invalid credentials\")\n\t}\n\n\taccess, refresh, err := CreateToken(&user.Username, &user.Id)\n\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn user, access, nil\n}\n\nfunc registerUser(db *gorm.DB, input *RegisterInput) (*User, *Token, error) {\n\tpwd, err := hashAndSalt(input.Password)\n\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar user User\n\tresult := db.Create(&User{\n\t\tUsername: input.Username,\n\t\tEmail:    input.Email,\n\t\tPassword: pwd,\n\t})\n\n\tif result.Error != nil {\n\t\treturn nil, nil, result.Error\n\t}\n\n\taccess, refresh, err := CreateToken(&user.Username, &user.Id)\n\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn &user, access, nil\n}\n\nvar graphqlSchema *graphql.Schema\n\nfunc CreateSchema() (*graphql.Schema, func(), error) {\n\ttype Resolver struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\n\tquery := graphql.NewObject(graphql.ObjectConfig{\n\t\tName: \"Query\",\n\t\tFields: graphql.Fields{\n\t\t\t\"user\": &graphql.Field{\n\t\t\t\tType: graphql.NewObject(graphql.ObjectConfig{\n\t\t\t\t\tName: \"User\",\n\t\t\t\t\tFields: graphql.Fields{\n\t\t\t\t\t\t\"username\": &graphql.Field{\n\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\tdb, err := connectDB()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Println(err)\n\t\t\t\t\t\treturn nil, errors.New(\"error connecting to database\")\n\t\t\t\t\t}\n\n\t\t\t\t\tdefer db.Close()\n\n\t\t\t\t\tuser, err := findUserByUsername(db, params.Args[\"username\"].(string))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\treturn &Resolver{Username: user.Username}, nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"products\": &graphql.Field{\n\t\t\tType: graphql.NewList(graphql.String),\n\t\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\t\tdb, err := connectDB()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t\treturn nil, errors.New(\"error connecting to database\")\n\t\t\t\t}\n\n\t\t\t\tdefer db.Close()\n\n\t\t\t\tvar products []Product\n\t\t\t\tresult := db.Order(\"id DESC\").Find(&products)\n\n\t\t\t\tif result.Error != nil {\n\t\t\t\t\treturn nil, result.Error\n\t\t\t\t}\n\n\t\t\t\treturn products, nil\n\t\t\t},\n\t\t},\n\t})\n\n\tmutation := graphql.NewObject(graphql.ObjectConfig{\n\t\tName: \"Mutation\",\n\t\tFields: graphql.Fields{\n\t\t\t\"login\": &graphql.Field{\n\t\t\t\tType: graphql.NewObject(graphql.ObjectConfig{\n\t\t\t\t\tName: \"Token\",\n\t\t\t\t\tFields: graphql.Fields{\n\t\t\t\t\t\t\"access\": &graphql.Field{\n\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"refresh\": &graphql.Field{\n\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\t\t\"username\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t},\n\t\t\t\t\t\"password\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\tdb, err := connectDB()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Println(err)\n\t\t\t\t\t\treturn nil, errors.New(\"error connecting to database\")\n\t\t\t\t\t}\n\n\t\t\t\t\tdefer db.Close()\n\n\t\t\t\t\tuser, token, err := loginUser(db, &LoginInput{Username: params.Args[\"username\"].(string), Password: params.Args[\"password\"].(string)})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\treturn token, nil\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"register\": &graphql.Field{\n\t\t\t\tType: graphql.NewObject(graphql.ObjectConfig{\n\t\t\t\t\tName: \"Token\",\n\t\t\t\t\tFields: graphql.Fields{\n\t\t\t\t\t\t\"access\": &graphql.Field{\n\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"refresh\": &graphql.Field{\n\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\t\t\"username\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t},\n  var x int = \"texte\"  // Erreur de type (bug)\n\t\t\t\t\t\"email\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t},\n\t\t\t\t\t\"password\": &graphql.ArgumentConfig{\n\t\t\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\tdb, err := connectDB()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Println(err)\n\t\t\t\t\t\treturn nil, errors.New(\"error connecting to database\")\n\t\t\t\t\t}\n\n\t\t\t\t\tdefer db.Close()\n\n\t\t\t\t\tuser, token, err := registerUser(db, &RegisterInput{Username: params.Args[\"username\"].(string), Email: params.Args[\"email\"].(string), Password: params.Args[\"password\"].(string)})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\treturn token, nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\n\ttype Schema struct {\n\t\tQuery    *graphql.Object\n\t\tMutation *graphql.Object\n\t}\n\n\tschema := &Schema{\n\t\tQuery:    query,\n\t\tMutation: mutation,\n\t}\n\treturn graphql.NewSchema(graphql.SchemaConfig{\n\t\tQuery:    query,\n\t\tMutation: mutation,\n\t}), func() {\n\t}, nil\n}\n\nfunc init() {\n\tvar err error\n\tgraphqlSchema, _, err = CreateSchema()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n", "langage": "go", "bugs_introduits": ["type_error_go", "wrong_assignment_go"], "corrections_appliquees": [], "timestamp": 1767008560.3266551, "tentative": 2}