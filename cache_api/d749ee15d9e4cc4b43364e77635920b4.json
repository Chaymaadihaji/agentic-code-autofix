{"nom_fichier": "models.py", "code": "python\nfrom fastapi import FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\nfrom jose import jwt, JWTError\nfrom passlib.context import CryptContext\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom mongoengine import connect, disconnect\nfrom fastapi import Body, Depends, Path, get\n\n# Configuration pour MongoDB\nMONGO_URI = \"mongodb://localhost:27017\"\nMONGO_DB = \"mondb\"\n\n# Configuration pour authentification JWT\nSECRET_KEY = \"secret\"\nALGORITHM = \"HS256\"\n\n# Config pour connexion à MongoDB\nconnect(\n    db=MONGO_DB,\n    alias='default',\n    host=[MONGO_URI],\n    alias='mongodb://localhost:27017/',\n    connect=True,\n    readPreference='nearest'\n)\n\n# Définition du modèle pour les utilisateurs\nclass Utilisateur(BaseModel):\n    id: str\n    username: str\n    password: str\n\n# Définition du modèle pour les JWT\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n# Définition de la stratégie d'authentification\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"login\")\n\n# Définition de la fonction pour créer un token\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n# Définition de la fonction pour vérifier un token\nasync def get_current_token(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload[\"sub\"]\n    except JWTError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n# Définition de l'application FastAPI\napp = FastAPI(\n    title=\"Mon API\",\n    description=\"API créé avec FastAPI et MongoDB\",\n    version=\"1.0.0\",\n    contact={\n        \"name\": \"Ton nom\",\n        \"url\": \"https://ton-site.fr\",\n        \"email\": \"tonemail@entreprise.com\"\n    },\n    termsOfService=\"https://ton-site.fr\",\n    license={\"name\": \"MIT\", \"url\": \"https://opensource.org/licenses/MIT\"}\n)\n\n# Dossier de documentation Swagger\ntags_metadata = [\n    {\n        \"name\": \"Utilisateurs\",\n        \"description\": \"API pour les utilisateurs\",\n    },\n    {\n        \"name\": \"Articles\",\n        \"description\": \"API pour les articles\",\n    },\n]\n\napp.openapi_tags = tags_metadata\n\n# Définition de la route pour la connexion\n@app.post(\"/login\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = await authenticate_user(form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token_expires = timedelta(minutes=30)\n    access_token = create_access_token(\n        data={\"sub\": user.username},\n        expires_delta=access_token_expires,\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n# Définition de la fonction pour authentifier un utilisateur\nasync def authenticate_user(username: str, password: str):\n    # À compléter avec votre fonction de vérification de mot de passe\n    return Utilisateur(id=\"001\", username=username, password=password)\n\n# Définition de la route pour obtenir les utilisateurs\n@app.get(\"/users/\", response_model=list[Utilisateur])\nasync def list_users():\n    return await User.objects().to_list()\n\n# Définition de la route pour obtenir un utilisateur\n@app.get(\"/users/{user_id}\", response_model=Utilisateur)\nasync def read_user(user_id: str):\n    return await User.objects(id=user_id).first()\n\n# Définition de la classe Utilisateur\nclass User:\n    _collection = MongoEngineDocumentCollectionField(\n        db=MongoEngine(), default=db[\"utilisateurs\"]\n    )\n\n    @classmethod\n    async def objects(cls):\n        collection = cls._collection()\n        return cls._collection.objects()\n\n# Gestion des erreurs\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request, exc):\n    return JSONResponse({\"error\": exc.detail}, status_code=exc.status_code)\n", "langage": "python", "bugs_introduits": [], "corrections_appliquees": [], "timestamp": 1767107072.7830312, "tentative": 2}