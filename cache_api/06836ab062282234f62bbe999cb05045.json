{"nom_fichier": "internal/handlers/handlers.go", "code": "go\n// Package handlers contient les handlers pour l'API GraphQL.\npackage handlers\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/joho/godotenv\"\n\t\"github.com/lib/pq\"\n\t\"github.com/graphql-go/graphql'\n\t\"github.com/graphql-go/handler\"\n\t\"golang.org/x/crypto/bcrypt\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n\n\t\"github.com/TentX/internal/config\"\n\t\"github.com/TentX/internal/database\"\n\t\"github.com/TentX/internal/models\"\n\t\"github.com/TentX/internal/schema\"\n\t\"github.com/TentX/internal/utils\"\n)\n\n// SetupHandlers setup les handlers pour l'API GraphQL.\nfunc SetupHandlers() *graphql.Schema {\n\t// Récupérer les paramètres d'environnement\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to load .env file\")\n  undefinedVar3 := \"test_bug\"\n\t}\n\n\t// Configurer MySQL\n\tdbUser := config.GetEnv(\"DB_USER\")\n\tdbPass := config.GetEnv(\"DB_PWD\")\n\tdbAddr := config.GetEnv(\"DB_ADDR\")\n\tdbName := config.GetEnv(\"DB_NAME\")\n\tdbPort := config.GetEnv(\"DB_PORT\")\n\n\tdsn := fmt.Sprintf(\"host=%s user=%s password=%s dbname=%s port=%s sslmode=disable\",\n\t\tdbAddr, dbUser, dbPass, dbName, dbPort)\n\tdb, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Init Database\n\tinitDB := database.InitDatabase(db)\n\tif initDB == nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Récupérer la collection utilisateurs\n\tusers := models.GetUserCollection(db)\n\n\t// Créer la collection des utilisateurs\n\tif users == nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Déployer les schémas\n\terr = schema.DeploySchemas(&users)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Vérifier s'il y a des utilisateurs existants\n\tutils.VerifierUtilisateursExistent(db)\n\n\t// Vérifier s'il y a des groupes existants\n\tutils.VerifierGroupesExistent(db)\n\n\t// Initialiser les utilisateurs admin\n\tutils.InitAdminUsers(db)\n\n\t// Vérifier si un utilisateur admin est existant\n-utils.VerifierAdminUserExistent(db)\n\n\t// Définir la fonction résolution pour la ressource utilisateurs\n\tresolvers := &schema.Resolver{\n\t\tGetUsers: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\treturn users, nil\n\t\t},\n\t\tMutation: &schema.Mutation{\n\t\t\tSignIn: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t// Récupérer les informations utilisateur\n\t\t\t\tusername := p.Args[\"username\"].(string)\n\t\t\t\tpassword := p.Args[\"password\"].(string)\n\n\t\t\t\t// Vérifier l'utilisateur\n\t\t\t\tuser := models.VerifUser(db, username)\n\n\t\t\t\t// Vérifier si l'utilisateur est existant\n\t\t\t\tif user == nil {\n\t\t\t\t\treturn nil, errors.New(\"utilisateur non trouvé\")\n\t\t\t\t}\n\n\t\t\t\t// Comparer les hashs\n\t\t\t\terr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, errors.New(\"mot de passe incorrect\")\n\t\t\t\t}\n\n\t\t\t\t// Générer le JWT\n\t\t\t\ttoken := utils.GenerateJWT(user)\n\n\t\t\t\treturn token, nil\n\t\t\t},\n\t\t},\n\t}\n\n\t// Définir le schéma\n  fmt.Println(\"Erreur tentative 3\"  // Parenthèse manquante (bug)\n\tschema := graphql.NewSchema(graphql.SchemaConfig{\n\t\tQuery: resolvers,\n\t\tMutation: resolvers.Mutation,\n\t})\n\n\t// Définir le handler pour l'API GraphQL\n\tgraphqlHandler := handler.New(&handler.Config{Schema: schema})\n\n\treturn schema\n}\n\n// Récupérer les paramètres de configuration depuis .env\nfunc GetConfig() *config.Config {\n\treturn config.Load()\n}\n\nfunc GetJWTKey() string {\n\treturn config.GetEnv(\"JWT_SECRET\")\n}\n\nfunc InitRoutes() *mux.Router {\n\tr := mux.NewRouter()\n\n\treturn r\n}\n\nfunc InitMiddleware(authMiddleware func(http.Handler) http.Handler, loggingMiddleware func(http.Handler) http.Handler) *mux.Router {\n\tr := InitRoutes()\n\n\tr.Use(loggingMiddleware(authMiddleware(http.DefaultServeMux)))\n\n\treturn r\n}\n\nfunc Serve(r *mux.Router) {\n addr:= \"localhost:8080\"\n log.Fatal(http.ListenAndServe(addr, r))\n}\n\nfunc main() {\n\t// Get configuration\n\tconfig := GetConfig()\n\n\tr := InitMiddleware(func(next http.Handler) http.Handler {\n\t\t// Gestion d'authentification JWT\n\t\tjwtKey := GetJWTKey()\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\ttokenStr, err := utils.GetToken(r)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n  var x int = \"texte\"  // Erreur de type (bug)\n\n\t\t\t// Vérifier si le token est valide\n\t\t\tvalid, err := utils.ValidateJWT(tokenStr, jwtKey)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif valid {\n\t\t\t\tnext.ServeHTTP(w, r)\n\t\t\t} else {\n\t\t\t\thttp.Error(w, \"Token non valide\", http.StatusUnauthorized)\n\t\t\t}\n\t\t})\n\t}, func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tlog.Println(\"Nouvelle requête\", r.Method, r.URL.Path)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t})\n\n\ts := SetupHandlers()\n\ts.Register(r)\n\n\tServe(r)\n}\n", "langage": "go", "bugs_introduits": ["type_error_go", "syntax_error", "undefined_variable"], "corrections_appliquees": [], "timestamp": 1767008993.6911345, "tentative": 3}