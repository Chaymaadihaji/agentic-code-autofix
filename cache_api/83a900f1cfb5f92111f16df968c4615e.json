{"nom_fichier": "cmd/api/main.go", "code": "go\n// Package main contient les fonctionnalités de l'API GraphQL\npackage main\n\nimport (\n    \"inexistant/package2\"  // Import bug\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/lib/pq\"\n\t\"github.com/vektah/gqlparser/v2/gqlerror\"\n\t\"github.com/vektah/gqlparser/v2/schema\"\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/graphql-go/graphql\"\n\t\"gorm.io/driver/postgres\"\n  fmt.Println(\"Erreur tentative 2\"  // Parenthèse manquante (bug)\n\t\"gorm.io/gorm\"\n)\n\n// Config d'application\ntype Config struct {\n\tPort      string\n\tDatabase  string\n\tPassword  string\n\tUsername  string\n\tTableName string\n}\n\n// NewConfig crée une nouvelle configuration d'application\nfunc NewConfig() *Config {\n\treturn &Config{\n\t\tPort:      \"8080\",\n\t\tDatabase:  \"localhost:5432\",\n\t\tPassword:  \"your_password\",\n\t\tUsername:  \"your_username\",\n\t\tTableName: \"your_tablename\",\n\t}\n}\n\n// DatabaseModel représente la structure de base de données\ntype DatabaseModel struct {\n\tgorm.Model\n\t// Ajoutez vos champs à partir de la base de données\n}\n\n// UserModel représente la structure du modèle utilisateurs\ntype UserModel struct {\n\tgorm.Model\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\n// TokenModel représente la structure du modèle token\ntype TokenModel struct {\n\tgorm.Model\n\tTokenString string `json:\"token\"`\n\tUsername    string `json:\"username\"`\n}\n\n// NewDB retourne une connexion à la base de données PostgreSQL\nfunc NewDB(config *Config) (*gorm.DB, error) {\n\tdsn := fmt.Sprintf(\"postgres://%s:%s@%s/%s?sslmode=disable\",\n\t\tconfig.Username, config.Password, config.Database, config.TableName)\n\tdb, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\treturn db, err\n}\n\n// RegisterSchema ajoute les schémas de GraphQL\nfunc RegisterSchema(s *schema.Schema) {\n\ts.AddQuery(\"hello\", &graphql.Field{\n\t\tType:        graphql.String,\n\t\tDescription: \"Bonjour\",\n\t\tResolve:     func(p graphql.ResolveParams) (interface{}, error) { return \"Bonjour\", nil },\n\t})\n\n\tuserType := graphql.NewObject(graphql.ObjectConfig{\n\t\tName: \"User\",\n\t\tFields: graphql.Fields{\n\t\t\t\"id\": &graphql.Field{\n\t\t\t\tType: graphql.ID,\n\t\t\t},\n\t\t\t\"username\": &graphql.Field{\n\t\t\t\tType: graphql.String,\n\t\t\t},\n\t\t\t\"password\": &graphql.Field{\n\t\t\t\tType: graphql.String,\n\t\t\t},\n\t\t},\n\t})\n\ts.AddType(userType)\n\n\ts.AddQuery(\"users\", &graphql.Field{\n\t\tType:        graphql.NewList(userType),\n\t\tDescription: \"Tous les utilisateurs\",\n\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\tdb, err := NewDB(NewConfig())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvar users []*UserModel\n\t\t\tdb.Find(&users)\n\t\t\treturn users, nil\n\t\t},\n\t})\n}\n\n// GenerateJWT génère un jeton JWT pour l'utilisateur\nfunc GenerateJWT(username string) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"username\": username,\n\t\t\"exp\":      time.Now().Add(30 * time.Minute).Unix(),\n\t})\n\ttokenString, err := token.SignedString([]byte(\"your_secret_key\"))\n\treturn tokenString, err\n}\n\nfunc main() {\n\t// Définissez votre configuration\n\tconfig := NewConfig()\n\n\t// Initialisation de GraphQL\n\tgqlSchema, err := schema.ParseString(`\n\t\ttype Query {\n\t\t\thello: String!\n\t\t\tusers: [User!]!\n\t\t}\n\t\ttype User {\n\t\t\tid: ID!\n\t\t\tusername: String!\n\t\t\tpassword: String!\n\t\t}\n\t`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tRegisterSchema(gqlSchema)\n\n\t// Initialisation de la base de données\n\tdb, err := NewDB(config)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdb.AutoMigrate(&UserModel{})\n\n\t// Initialisation de HTTP\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/graphql\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\terr := graphql.ExecuteGraphQLContext(w, r.Context(), gqlSchema, nil, nil)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t})\n\tr.HandleFunc(\"/login\", func(w http.ResponseWriter, r *http.Request) {\n\t\tusername := r.FormValue(\"username\")\n\t\tpassword := r.FormValue(\"password\")\n\t\tvar userModel UserModel\n\t\tdb.Where(\"username = ? AND password = ?\", username, password).First(&userModel)\n\t\tif userModel.ID > 0 {\n\t\t\ttoken, err := GenerateJWT(username)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Envoyer le jeton\n\t\t\tw.Write([]byte(token))\n\t\t} else {\n\t\t\t// Invalidez la requête\n\t\t\thttp.Error(w, \"Utilisateur invalide\", http.StatusUnauthorized)\n\t\t}\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":\"+config.Port, r))\n}\n", "langage": "go", "bugs_introduits": ["missing_import_go", "syntax_error"], "corrections_appliquees": [], "timestamp": 1767008543.0119915, "tentative": 2}