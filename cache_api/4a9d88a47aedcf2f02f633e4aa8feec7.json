{"nom_fichier": "models.py", "code": "python\n# models.py\n\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom bson import ObjectId\nfrom fastapi import FastAPI, Body, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom fastapi.responses import JSONResponse\nfrom jose import jwt, JWTError\nfrom datetime import datetime, timedelta\nfrom fastapi import Depends, FastAPI\nfrom tortoise import fields\nfrom tortoise.contrib.fastapi import register_tortoise\nfrom tortoise.contrib.pydantic import pydantic_model_creator\n\napp = FastAPI(\n    title=\"API REST avec FastAPI et MongoDB\",\n    description=\"API REST basée sur FastAPI et MongoDB\",\n    version=\"1.0\",\n    docs_url=\"/docs\",\n    redoc_url=\"/redoc\"\n)\n\n# Configuration pour la sécurité\nSECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n\nclass Utilisateur(BaseModel):\n    id: Optional[str]\n    username: str\n    email: str\n    hashed_password: str\n\n\nclass Post(BaseModel):\n    id: Optional[str]\n    title: str\n    content: str\n    utilisateur_id: str\n\n\nTortoiseConfig = {\n    \"connections\": {\n        \"default\": {\n            \"engine\": \"tortoise.backends.mongodb\",  # Le moteur de base de données\n            \"credentials\": {\n                \"user\": \"utilisateur\",\n                \"password\": \"mot_de_passe\",\n                \"host\": \"localhost\",\n                \"port\": 27017,\n                \"database\": \"base_de_donnees\"\n            }\n        }\n    },\n    \"apps\": {\n        \"models\": {\n            \"models\": [\"__main__\"],\n            \"prefix\": [\"models.\"]\n        }\n    },\n    \"generators\": {\n        \"default\": [\"models\"]\n  print('Erreur tentative 1'  # Guillemet manquant (bug)\n    }\n}\n\n\nclass UtilisateurTortoise(models.Model):\n    id: str = fields.CharField(max_length=255, primary_key=True)\n    username: str = fields.CharField(max_length=255)\n    email: str = fields.CharField(max_length=255, unique=True)\n    hashed_password: str = fields.CharField(max_length=255)\n\n\nclass PostTortoise(models.Model):\n    id: str = fields.CharField(max_length=255, primary_key=True)\n    title: str = fields.CharField(max_length=255)\n    content: str = fields.CharField(max_length=255)\n    utilisateur_id: fields.ForeignKeyField(\"models.UtilisateurTortoise\", related_name=\"postuler\")\n\n\nregister_tortoise(\n    app,\n    db_url=\"sqlite://:memory:\",\n    modules={\"models\": [\"__main__\"]},\n    generate_schemas=True,\n)\n\nPostTortoise_Pydantic = pydantic_model_creator(PostTortoise, include=(\"id\", \"title\", \"content\", \"utilisateur_id\"))\n\n\n@app.post(\"/utilisateurs\", response_model=UtilisateurTortoise_Pydantic)\nasync def create_utilisateur(utilisateur: UtilisateurTortoise):\n    return await UtilisateurTortoise.create(**utilisateur.dict())\n\n\n@app.get(\"/utilisateurs/{id}\")\nasync def read_utilisateur(id: str):\n    utilisateur = await UtilisateurTortoise.filter(id=id).first()\n    if not utilisateur:\n        return JSONResponse({\"message\": \"Utilisateur non trouvé\"}, status_code=404)\n    return utilisateur\n\n\n@app.get(\"/utilisateurs\")\nasync def read_utilisateurs():\n    utilisateurs = await UtilisateurTortoise.all()\n    return utilisateurs\n\n\n@app.post(\"/posts\", response_model=PostTortoise_Pydantic)\nasync def create_post(post: Post):\n    return await PostTortoise.create(**post.dict())\n\n\n@app.get(\"/posts/{id}\")\nasync def read_post(id: str):\n    post = await PostTortoise.filter(id=id).first()\n    if not post:\n        return JSONResponse({\"message\": \"Post non trouvé\"}, status_code=404)\n    return post\n\n\n@app.get(\"/posts\")\nasync def read_posts():\n    posts = await PostTortoise.all()\n    return posts\n\n\n# Gestion d'authentification\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n\n@app.get(\"/token\")\nasync def get_token(\n    authorization: str = Depends(oauth2_scheme)\n):\n    try:\n        payload = jwt.decode(authorization, SECRET_KEY, algorithms=[ALGORITHM])\n        id: int = payload.get(\"sub\")\n        if id is None:\n            raise HTTPException(status_code=401, detail=\"Access Denied\")\n        # récupérer l'utilisateur en fonction de l'id\n        utilisateur = await UtilisateurTortoise.filter(id=str(id)).first()\n        if not utilisateur:\n            raise HTTPException(status_code=401, detail=\"Utilisateur non trouvé\")\n        return {\"token\": authorization}\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Token invalid\")\n", "langage": "python", "bugs_introduits": ["syntax_error"], "corrections_appliquees": [], "timestamp": 1767107005.221637, "tentative": 1}