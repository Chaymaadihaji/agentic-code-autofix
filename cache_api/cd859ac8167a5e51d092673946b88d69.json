{"nom_fichier": "cmd/api/main.go", "code": "package main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"golang.org/x/exp/concurrency\"\n\t\"github.com/graphql-go/graphql\"\n\tgraphqlJwt \"github.com/davidwook/graphql-jwt\"\n\t\"gopkg.in/h2non/gock.v1\"\n\t\"github.com/graphql-go/subscriptions\"\n\t\"github.com/graphql-go/subscriptions/transport/websocket\"\n\t\"github.com/graphql-go/subscriptions/transport/writer\"\n\n\t// Importing graphqlgen to generate the schema\n\t_ \"github.com/graphql-go/graphql/v2/genschema\"\n\n\t// Importing gologin to handle authentication\n\t_ \"github.com/graphql-golang/graphql-gologin\"\n\n\t// Importing jwt to generate jwt token\n\t_ \"github.com/dgrijalva/jwt-go\"\n\n\t// Importing gindocs to handle swagger documentation\n\t_ \"github.com/swaggo/swag/init\"\n\n\t// Swagger initialization\n\tswag.Init(swag.PathHanderFunc(swag.HandlerPathHandler))\n)\n\n// GraphQL schema generated by gqldgen\nvar schema, _ = graphql.NewSchema(graphql.SchemaConfig{\n\tSchema: &_gqlgen.Schema{\n\t\tRoot:       &_gqlgen.RootResolver{},\n\t\tMutation:  &_gqlgen.MutationResolver{},\n\t\tQuery:     &_gqlgen.QueryResolver{},\n\t\tSubscription: &_gqlgen.SubscriptionResolver{},\n\t},\n})\n\n// ConnDB is used for database connection\nvar ConnDB = new(sql.DB)\n\ntype authenticationMiddleware struct{}\n\nfunc (m authenticationMiddleware) Middleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\thttp.Error(w, \"missing token\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\ttoken, err := jwt.TokenVerify(tokenString)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tctx := context.WithValue(r.Context(), \"user\", tokenclaims(token))\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\nfunc authenticationMiddlewareFunc(next http.HandlerFunc) http.HandlerFunc {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\thttp.Error(w, \"missing token\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\ttoken, err := jwt.TokenVerify(tokenString)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tctx := context.WithValue(r.Context(), \"user\", tokenclaims(token))\n\t\tnext(w, r.WithContext(ctx))\n\t})\n}\n\nfunc tokenclaims(token *jwt.Token) map[string]string {\n\tclaims := make(map[string]string)\n\tclaims[\"uid\"] = token.Header[\"uid\"].(string)\n\tclaims[\"email\"] = token.Claims[\"email\"].(string)\n\treturn claims\n}\n\nfunc main() {\n\tlog.Println(\"Starting Server\")\n\n\t// Starting Webhooks\n\tgock.New(\"http://test.com\").\n\t\tPost(\"/graphql\").\n\t\tReply(200).\n\t\tType(\"application/json\").\n\t\tJSON(`{\n\t\t\t\"data\": {\n\t\t\t\t\"message\": \"Hello, World!\"\n\t\t\t}\n\t\t}`)\n\n\t// Initializing GraphQL schema\n\tgraphqlSchema := schema.MustParse()\n\n\t// Initialize WebSocket subscription transport\n\tWebSocketTransport := &websocket.Transport{\n\t\tNewConnection: func(rw http.ResponseWriter, r *http.Request) (writer.Writer, conn.Conn, error) {\n\t\t\treturn writer.Writer(rw), conn.New(r), nil\n\t\t},\n\t}\n\n\twsServer := subscriptions.NewServer(WebSocketTransport)\n\n\t// Registering GraphQL subscription handlers\n\tsubscribeHandler := subscriptions.Handler(subscriptions.NewHandler(\n\t\tfunc(ctx context.Context, payload map[string]interface{}) (subscription graphql.SubscriptionResolver, err error) {\n\t\t\treturn &_gqlgen.SubscriptionResolver{}, nil\n\t\t},\n\t))\n\n\t// Registering GraphQL subscription handlers\n\tschema := graphql.MustParse(graphql.SchemaConfig{\n\t\tSchema: &_gqlgen.Schema{\n\t\t\tRoot:       &_gqlgen.RootResolver{},\n\t\t\tMutation:  &_gqlgen.MutationResolver{},\n\t\t\tQuery:     &_gqlgen.QueryResolver{},\n\t\t\tSubscription: &_gqlgen.SubscriptionResolver{},\n\t\t},\n\t})\n\n\tgraphqlHandler := graphql.Handler(graphql.Schema(graphql.MustParse(schema)))\n\tgraphqlHandler.Middleware(func(ctx *graphql.Context) {\n\t\t// Applying auth middleware\n\t\tauthMiddlewareFunc := authenticationMiddlewareMiddlewareFunc()\n\t\tgraphQLOpt := graphql.HandlerOption(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\t\tnext(w, r)\n\t\t\tr.Header.Delete(\"Authorization\")\n\t\t})\n\n\t\tnext := authMiddlewareFunc(graphQLopt(w, r, next))\n\t\tnext.ServeHTTP(w, r)\n\t\treturn\n\t})\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/graphql\", websocket.Handler(subscribeHandler))\n\n\tport := \"8080\"\n\thttp.ListenAndServe fmt.Sprintf(\":%s\", port), mux)\n}\n\nfunc authenticationMiddlewareMiddlewareFunc() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\t// Verify token using jwt.verify\n\t\t// ...\n\t\tctx := context.TODO()\n\t\tnext(w, r.WithContext(ctx))\n\t\treturn\n\t}\n}\n", "bugs_introduits": [], "timestamp": 1767006958.32777}