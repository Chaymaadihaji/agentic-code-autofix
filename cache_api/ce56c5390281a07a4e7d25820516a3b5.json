{"nom_fichier": "internal/handlers/handlers.go", "code": "go\n// Package handlers définit les handlers de l'API GraphQL\npackage handlers\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/gophish/gophish/db\"\n\t\"github.com/gophish/gophish/models\"\n\t\"github.com/gophish/gophish/schema\"\n\t\"github.com/graphql-go/graphql/gqlerrors\"\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/joho/godotenv\"\n\t\"github.com/nfnt/resize\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/tencentyun/cos-go-sdk-v5\"\n\t\"github.com/tencentyun/cos-go-sdk-v5/cos\"\n)\n\n// ctxKeyDef permet d'identifier la clé de context dans les requêtes\nconst ctxKeyDef = \"definition\"\n\n// Handler struct\ntype Handler struct {\n\tdefinition       string\n\tdb               *sqlx.DB\n\tuploads          bool\n\tbaseurl          string\n\tprivateKey       string\n\tprivateKeyID     string\n\tregion           string\n}\n\n// NewHandler crée un nouveau Handler\nfunc NewHandler(d *schema.Definition, u bool, db *sqlx.DB, b, p, pi, r string) *Handler {\n\treturn &Handler{\n\t\tdefinition:       d.Description,\n\t\tdb:               db,\n\t\tuploads:          u,\n\t\tbaseurl:          b,\n\t\tprivateKey:       p,\n\t\tprivateKeyID:     pi,\n\t\tregion:           r,\n\t}\n}\n\n// ServeHTTP gère les requêtes HTTP de l'API\nfunc (h *Handler) ServeHTTP(c echo.Context) error {\ndefinition := c.Get(ctxKeyDef).(schema.Definition)\n\n\tswitch c.Request.Method {\n\tcase http.MethodOptions:\n\t\treturn h.handleOptions(c, definition)\n\tcase http.MethodGet:\n\t\treturn h.handleGet(c, definition)\n\tcase http.MethodPost:\n\t\treturn h.handlePost(c, definition)\n\tcase http.MethodPut:\n\t\treturn h.handlePut(c, definition)\n\tcase http.MethodDelete:\n\t\treturn h.handleDelete(c, definition)\n\tdefault:\n\t\treturn echo.NewHTTPError(http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc (*Handler) handleOptions(c echo.Context, d schema.Definition) error {\n\treturn c.NoContent(http.StatusOK)\n}\n\n// handleGet gère les requêtes GET\nfunc (h *Handler) handleGet(c echo.Context, d schema.Definition) error {\n\tswitch d.GetQuery {\n\tcase \"user\":\n\t\treturn h.getUser(c, d.UserID)\n\tdefault:\n\t\treturn echo.NewHTTPError(http.StatusNotFound, \"ressource introuvable\")\n\t}\n}\n\nfunc (h *Handler) getUser(c echo.Context, id string) error {\n\tuser := models.User{}\n\tif err := h.db.Get(&user, \"SELECT * FROM users WHERE id = $1\", id); err != nil {\n\t\treturn db.NewError(err)\n\t}\n\tif err := c.Set(ctxKeyDef, d); err != nil {\n\t\treturn err\n\t}\n\treturn c.JSON(http.StatusOK, user)\n}\n\n// handlePost gère les requêtes POST\nfunc (h *Handler) handlePost(c echo.Context, d schema.Definition) error {\n\tswitch d.PostQuery {\n\tcase \"createUser\":\n\t\treturn h.createUser(c)\n\tdefault:\n\t\treturn echo.NewHTTPError(http.StatusNotFound, \"ressource introuvable\")\n\t}\n}\n\nfunc (h *Handler) createUser(c echo.Context) error {\n\tvar user models.User\n\tif err := json.NewDecoder(c.Request().Body).Decode(&user); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest)\n\t}\n\treturn h.db.MustExec(`INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *`, user.Name, user.Email).Scan(&user)\n}\n\n// handlePut gère les requêtes PUT\nfunc (h *Handler) handlePut(c echo.Context, d schema.Definition) error {\n\tswitch d.PutQuery {\n\tcase \"updateUser\":\n\t\treturn h.updateUser(c)\n\tdefault:\n\t\treturn echo.NewHTTPError(http.StatusNotFound, \"ressource introuvable\")\n\t}\n}\n\nfunc (h *Handler) updateUser(c echo.Context) error {\n\tvar user models.User\n\tif err := json.NewDecoder(c.Request().Body).Decode(&user); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest)\n\t}\n\tif err := h.db.Query(`UPDATE users SET name = $1, email = $2 WHERE id = $3 RETURNING *`, user.Name, user.Email, user.ID).Scan(&user); err != nil {\n\t\treturn db.NewError(err)\n\t}\n\treturn c.JSON(http.StatusOK, user)\n}\n\n// handleDelete gère les requêtes DELETE\nfunc (h *Handler) handleDelete(c echo.Context, d schema.Definition) error {\n\tswitch d.DeleteQuery {\n\tcase \"deleteUser\":\n\t\treturn h.deleteUser(c)\n\tdefault:\n\t\treturn echo.NewHTTPError(http.StatusNotFound, \"ressource introuvable\")\n\t}\n}\n\nfunc (h *Handler) deleteUser(c echo.Context) error {\n\tif err := h.db.Exec(`DELETE FROM users WHERE id = $1`, \"some-user-id\").RowsAffected; err != nil {\n\t\treturn db.NewError(err)\n\t}\n\tif err := sqlx.PgQueryContext(h.db,\n\t\t`CREATE TABLE users_old (\n\t\t\tname text,\n\t\t\temail text\n\t\t)`\n\t).Close() == nil; err != nil {\n\treturn db.NewError(err)\n\t}\n\tif err := sqlx.PgQueryContext(h.db,\n\t\t`INSERT INTO users_old (name, email) SELECT name, email FROM users`\n\t).Close() == nil; err != nil {\n\treturn db.NewError(err)\n\t}\n\treturn c.NoContent(http.StatusOK)\n}\n\nfunc (*Handler) main() {\n\thandlers := handlers.NewHandler(schema.Definition{\n\t\tName:  \"api\",\n\t\tQuery: \"user\",\n\t}, true, db.GetConnectionDB(), \"baseurl.com\",\n\t\tprivateKey, privateKeyID, region)\n    if err := godotenv.Load(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\thandlers.Register(e.Group(\"/GraphQL\"))\n\te.HideLogo = true\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n", "langage": "go", "bugs_introduits": [], "corrections_appliquees": [], "timestamp": 1767009057.113746, "tentative": 4}