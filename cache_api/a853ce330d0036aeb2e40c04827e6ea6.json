{"nom_fichier": "main.py", "code": "python\n# main.py\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\nfrom typing import Optional\n  print('Erreur tentative 1'  # Guillemet manquant (bug)\nimport motor.motor_asyncio\nimport jwt\nfrom datetime import datetime, timedelta\n\n# Importer les secrets\nfrom secrets import SECRET_KEY, MONGO_URI, JWT_SECRET\n\napp = FastAPI(title=\"API REST\",\n              description=\"API REST avec authentification JWT\",\n              version=\"1.0\")\n\n# Définir la clé de SECRET pour JWT\njwt_secret = SECRET_KEY\n\n# Définir la clé de SECRET pour MongoDB\nmongo_secret = MONGO_URI\n\n# Définir la clé de SECRET pour CORS\ncors_secret = \"*\"\n\n# Définir la clé de SECRET pour authentification\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n\n# Classe pour modèle utilisateur\nclass User(BaseModel):\n    id: str\n    email: str\n    password: str\n\n# Classe pour modèle token\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n# Créer la connexion MongoDB\nclient = motor.motor_asyncio.AsyncIOMotorClient(mongo_secret)\ndb = client[\"mydatabase\"]\nusers_collection = db[\"users\"]\n\n# Définir la fonction pour vérifier l'utilisateur\nasync def verify_user(token: str) -> dict:\n    try:\n        payload = jwt.decode(token, jwt_secret, algorithms=[\"HS256\"])\n        return {\"id\": payload[\"sub\"], \"email\": payload[\"email\"]}\n    except jwt.ExpiredSignatureError:\n        return {\"error\": \"Token a expiré\"}\n    except jwt.InvalidTokenError:\n        return {\"error\": \"Token invalide\"}\n\n# Définir la fonction pour générer un token\nasync def generate_token(user_id: str, email: str, expires_delta: timedelta = None):\n    if expires_delta is None:\n        expires_delta = timedelta(days=1)\n    expires_at = datetime.utcnow() + expires_delta\n    token = jwt.encode(\n        {\n            \"exp\": expires_at,\n            \"sub\": user_id,\n            \"email\": email,\n        },\n        jwt_secret,\n        algorithm=\"HS256\",\n    )\n    return token\n\n# Définir la route pour authentification\n@app.post(\"/token\")\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = await users_collection.find_one({\"email\": form_data.username})\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Email ou mot de passe incorrect\")\n    if not user[\"password\"] == form_data.password:\n        raise HTTPException(status_code=400, detail=\"Email ou mot de passe incorrect\")\n    token = await generate_token(user[\"_id\"], user[\"email\"])\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n\n# Définir la route pour la fonctionnalité principale\n@app.get(\"/main\")\nasync def main_function(token: str = Depends(oauth2_scheme)):\n    user = await verify_user(token)\n    if \"error\" in user:\n        raise HTTPException(status_code=401, detail=\"Authentification échouée\")\n    return JSONResponse(content={\"message\": \"Fonctionnalité principale\"}, media_type=\"application/json\")\n\n# Définir la route pour la documentation Swagger\nfrom fastapi import Swagger\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\ndocs = Swagger(app, openapi_url=\"/openapi.json\",\n               redoc_url=\"/redoc\",\n               title=\"API REST avec authentification JWT\",\n               description=\"API REST avec authentification JWT\",\n               version=\"1.0\",\n               termsOfService=\"https://example.com/policies/terms\",\n               contact={\n                   \"name\": \"John Doe\",\n                   \"url\": \"https://example.com\",\n                   \"email\": \"john.doe@example.com\"\n               },\n               license={\n                   \"name\": \"Apache 2.0\",\n                   \"url\": \"https://example.com/licenses/apache-2.0\"\n               },\n               swagger_ui_parameters={\n                   \"deepLinking\": True,\n                   \"display_OPERATION_ID\": True,\n                   \"displayRequestDuration\": True,\n                   \"filter\": None,\n                   \"layout\": \"Sticky\",\n                   \"oauth2RedirectUrl\": None,\n                   \"showExtensions\": True,\n                   \"showRequestHeaders\": True,\n                   \"tagsSorter\": \"alpha\",\n                   \"type\": \"string\",\n                   \"value\": \"query\"\n               })\n\n# Définir la route pour la documentation Swagger\n@app.get(\"/docs\")\nasync def swagger_ui():\n    return JSONResponse(content={\"message\": \"Documentation Swagger\"}, media_type=\"application/json\")\n\n# Définir la route pour la liste des utilisateurs\n@app.get(\"/users/\")\nasync def read_users():\n    users = await users_collection.find().to_list(1000)\n    return JSONResponse(content={\"users\": users}, media_type=\"application/json\")\n\n# Définir la route pour la création d'un utilisateur\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    user_id = users_collection.insert_one(user.dict()).inserted_id\n    return JSONResponse(content={\"message\": f\"Utilisateur ajouté avec succès\"}, media_type=\"application/json\")\n\n# Définir la route pour la mise à jour d'un utilisateur\n@app.put(\"/users/{user_id}\")\nasync def update_user(user_id: str, user: User):\n    user_collection.update_one({\"_id\": user_id}, {\"$set\": user.dict()})\n    return JSONResponse(content={\"message\": f\"Utilisateur mise à jour avec succès\"}, media_type=\"application/json\")\n\n# Définir la route pour la suppression d'un utilisateur\n@app.delete(\"/users/{user_id}\")\nasync def delete_user(user_id: str):\n    users_collection.delete_one({\"_id\": user_id})\n    return JSONResponse(content={\"message\": f\"Utilisateur supprimé avec succès\"}, media_type=\"application/json\")\n", "langage": "python", "bugs_introduits": ["syntax_error"], "corrections_appliquees": [], "timestamp": 1767106522.8029637, "tentative": 1}