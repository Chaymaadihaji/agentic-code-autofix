{"nom_fichier": "main.py", "code": "python\n\"\"\"\nProjet principal : API REST en Python avec FastAPI, MongoDB, authentification JWT, CORS, et documentation Swagger\n\"\"\"\n\nfrom fastapi import FastAPI, status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom bson import ObjectId\nfrom pymongo import MongoClient\nfrom datetime import datetime, timedelta\nfrom jwt import encode, decode\nfrom typing import Optional\nimport secrets\nfrom pydantic import EmailStr\n\napp = FastAPI(\n    title=\"API REST\",\n    description=\"API REST sécurisée avec JWT\"\n)\n\n# Configuration MongoDB\nMONGO_URI = \"mongodb://localhost:27017/\"\nMONGO_DB = \"database\"\nMONGO_COLLECTION = \"users\"\n\n# Configuration authentification\nSECRET_KEY = secrets.token_urlsafe(32)\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRES_IN = timedelta(minutes=30)\nREFRESH_TOKEN_EXPIRES_IN = timedelta(days=1)\n\n# Création client MongoDB\nclient = MongoClient(MONGO_URI)\ndb = client[MONGO_DB]\ncollection = db[MONGO_COLLECTION]\n\n# Definition de la structure de données des utilisateurs\nclass User(BaseModel):\n    id: Optional[str]\n    email: EmailStr\n    password: str\n\n# Definition de la structure de données du token JWT\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n# Definition de la structure de données de requête de login\nclass LoginForm(OAuth2PasswordRequestForm):\n    pass\n\n# Definition de la structure de données de requête de refresh token\nclass RefreshTokenRequest(BaseModel):\n    refresh_token: str\n\n# Règle de sécurisation pour permettre l'authentification\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"login\")\n\n# Fichier de configuration pour la base de données\nclass Config:\n    MONGO_URI = MONGO_URI\n    MONGO_DB = MONGO_DB\n    MONGO_COLLECTION = MONGO_COLLECTION\n\n# Initialisation de la base de données\ndef init_db():\n    # Vérifie si la base de données existe\n    if collection.count_documents({}) == 0:\n        # Crée un utilisateur administrateur s'il n'y en a pas\n        user_admin = {\n            \"email\": \"admin@example.com\",\n            \"password\": secrets.token_hex(16)\n        }\n        collection.insert_one(user_admin)\n\n# Initialisation de la base de données\ninit_db()\n\n# Route pour la récupération des tokens\n@app.post(\"/login\", response_model=Token)\nasync def login(form_data: LoginForm):\n    # Récupération de l'utilisateur\n    user = collection.find_one({\"email\": form_data.username})\n    \n    if not user:\n        return JSONResponse(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            content={\"detail\": \"Nom d'utilisateur ou mot de passe incorrect\"}\n        )\n    \n    # Vérification du mot de passe\n    if user[\"password\"] != form_data.password:\n        return JSONResponse(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            content={\"detail\": \"Nom d'utilisateur ou mot de passe incorrect\"}\n        )\n    \n    # Génération du token JWT\n    payload = {\n        \"sub\": user[\"email\"],\n        \"exp\": datetime.utcnow() + timedelta(minutes=30)\n    }\n    token = encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n    \n    # Récupération du refresh token\n    refresh_token = collection.update_one(\n        {\"email\": form_data.username},\n        {\"$addToSet\": {\"refresh_tokens\": token}}\n    )\n    \n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n\n# Route pour la récupération d'un utilisateur\n@app.get(\"/users/{user_id}\", response_model=User)\nasync def read_user(user_id: str):\n    # Récupération de l'utilisateur\n    user = collection.find_one({\"_id\": ObjectId(user_id)})\n    \n    if not user:\n        return JSONResponse(\n            status_code=status.HTTP_404_NOT_FOUND,\n            content={\"detail\": \"Utilisateur non trouvé\"}\n        )\n    \n    return user\n\n# Route pour la récupération des documents\n@app.get(\"/docs\", include_in_schema=False)\nasync def read_docs():\n    return {\"docs\": \"API REST sécurisée avec JWT\"}\n\n# Route pour la récupération des erreurs\n@app.get(\"/errors\", include_in_schema=False)\nasync def read_errors():\n    try:\n  print('Erreur tentative 3'  # Guillemet manquant (bug)\n        # Récupération d'un utilisateur inexistant\n        user = collection.find_one({\"_id\": ObjectId(\"1234567890\")})\n        \n        if user:\n            return user\n        else:\n            raise Exception(\"Utilisateur non trouvé\")\n    \n    except Exception as e:\n        return JSONResponse(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            content={\"detail\": str(e)}\n        )\n", "langage": "python", "bugs_introduits": ["syntax_error"], "corrections_appliquees": [], "timestamp": 1767107101.5780663, "tentative": 3}