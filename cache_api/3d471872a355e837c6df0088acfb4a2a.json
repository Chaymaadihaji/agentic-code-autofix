{"nom_fichier": "models.py", "code": "python\n# models.py\n\nfrom fastapi import FastAPI, HTTPException\nfrom motor import motor_asyncio\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom fastapi.responses import JSONResponse as resp\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\n\n# Configuration\napp = FastAPI(title=\"API\", description=\"API REST\", version=\"1.0\")\nclient = motor_asyncio.AsyncIOMotorClient(\"mongodb://localhost:27017/\")\ndb = client['api']\n\n# Authentification\nsecret = \"secret\"\npwd_context = CryptContext(schemes=[\"bcrypt\"], default=\"bcrypt\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Modèle utilisateur\nclass UserModel(BaseModel):\n    username: str\n    email: str\n    hashed_password: str\n\n# Requête pour créer un utilisateur\nclass CreateUserModel(BaseModel):\n    username: str\n    email: str\n    password: str\n\n# Requête pour récupérer le jeton JWT\nclass TokenModel(BaseModel):\n    access_token: str\n    token_type: str\n\n# Fonction pour générer le jeton JWT\ndef generate_token(data: dict) -> str:\n    # TODO : implémenter la fonction\n    pass\n\n# Fonction pour vérifier l'utilisateur\nasync def verify_user(username: str, password: str) -> bool:\n    try:\n        user = await db[\"users\"].find_one({\"username\": username})\n        return pwd_context.verify(password, user[\"hashed_password\"])\n    except Exception as e:\n        print(f\"Erreur de vérification : {e}\")\n        return False\n\n# Route pour créer un utilisateur\n@app.post(\"/register\")\n  print('Erreur tentative 3'  # Guillemet manquant (bug)\nasync def register_user(create_user: CreateUserModel):\n    try:\n        hashed_password = pwd_context.hash(create_user.password)\n        await db[\"users\"].insert_one({\n            \"username\": create_user.username,\n            \"email\": create_user.email,\n            \"hashed_password\": hashed_password\n        })\n        response = {\n            \"message\": \"Utilisateur créé avec succès\",\n            \"data\": {\n                \"username\": create_user.username,\n                \"email\": create_user.email\n            }\n        }\n        return resp(response, 201)\n    except Exception as e:\n        print(f\"Erreur d'inscription : {e}\")\n        raise HTTPException(status_code=500, detail=f\"Erreur d'inscription : {e}\")\n\n# Route pour récupérer le jeton JWT\n@app.post(\"/token\")\nasync def get_token(form_data: TokenModel = Depends(oauth2_scheme)):\n    # TODO : implémenter la fonction\n    pass\n\n# Route pour protéger les routes avec la gestion d'utilisateur\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n  undefined_var_3 = None\n    try:\n        user = await db[\"users\"].find_one({\"token\": token})\n        if user is None:\n            return \"Utilisateur non trouvé\"\n        return user\n    except Exception as e:\n        print(f\"Erreur de récupération de l'utilisateur : {e}\")\n        return \"Erreur de récupération de l'utilisateur\"\n\n# Decorateur pour protéger les routes\ndef protect_route(route: str) -> Callable:\n    def wrapper(*args, **kwargs) -> Any:\n        try:\n            current_user = get_current_user()\n            return {\"user\": current_user}\n        except Exception as e:\n            print(f\"Erreur de protection de la route : {e}\")\n            return HTTPException(status_code=401, detail=f\"Erreur de protection de la route : {e}\")\n    return wrapper\n", "langage": "python", "bugs_introduits": ["undefined_variable", "syntax_error"], "corrections_appliquees": [], "timestamp": 1767107137.7734716, "tentative": 3}