{"nom_fichier": "cmd/api/main.go", "code": "go\n// File: cmd/api/main.go\npackage main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/relay\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/lib/pq\"\n\t\"golang.org/x/sync/errgroup\"\n\n\t\"github.com/astaxie/beego/orm\"\n\t_ \"github.com/lib/pq\"\n)\n\nfunc main() {\n\tinitDB()\n\tinitGraphQL()\n\n\t// Base de données\n\tdb, err := sql.Open(\"postgres\", os.Getenv(\"DATABASE_URL\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Serveur GraphQL\n\tsrv := graphql.NewServer(graphql.Schema(graphql.NewExecutableSchema(graphql.Config{Resolvers: &graphQLResolvers{}})))\n\tsrv.SetQueryHandler(relay.NewClient())\n\tsrv.RegisterResolver(func() (graphql.Resolver, error) {\n\t\treturn new(graphQLResolver), nil\n\t})\n\n\t// Serveur HTTP\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"API GraphQL en fonction\")\n\t})\n\n\te.POST(\"/graphql\", func(c echo.Context) error {\n\t\treturn srv.ServeHTTP(c.Response().Writer, c.Request())\n\t})\n\n\tgo func() {\n\t\te.Logger.Fatal(e.Start(\":1323\"))\n\t}()\n\n\t// Subscriptions WebSocket\n\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\n\t// Serveur WebSocket\n\twsSrv := http.Server{\n\t\tAddr: \":8080\",\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.URL.Path != \"/ws\" {\n\t\t\t\thttp.Error(w, \"not found\", http.StatusNotFound)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif r.Method != http.MethodGet {\n\t\t\t\thttp.Error(w, \"only GET is allowed\", http.StatusMethodNotAllowed)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := upgrader.Upgrade(w, r, nil); err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer upgrader.Close()\n\t\t\tfor {\n\t\t\t\t_, message, err := upgrader.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Println(string(message))\n\t\t\t\terr = upgrader.WriteMessage(websocket.TextMessage, []byte(\"Hello, client!\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t}\n\n\tgo func() {\n\t\tlog.Fatal(wsWithReconnect(wsWithDB(wsSrv)))\n\t}()\n\n\t// Gestion de signaux système\n\tg, ctx := errgroup.WithContext(context.Background())\n\tg.Go(func() error {\n\t\treturn e.Start(\":1323\")\n\t})\n\tg.Go(func() error {\n\t\treturn wsSrv.ListenAndServe()\n\t})\n\tg.Go(func() error {\n\t\tsigs := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigs, os.Interrupt, os.Kill)\n\t\tselect {\n\t\tcase <-sigs:\n\t\t\tgCtx, gCancel := context.WithTimeout(ctx, 5*time.Second)\n\t\t\tdefer gCancel()\n\t\t\tlog.Println(\"Arrêt du serveur...\")\n\t\t\te.Logger.Fatal(e.Shutdown(gCtx))\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\t}\n\t\treturn nil\n\t})\n\tg.Wait()\n}\n\nfunc withsDB(srv http.Server) http.Server {\n\treturn http.Server{\n\t\tAddr: \":8080\",\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t// ...\n\t\t}),\n\t}\n}\n\nfunc withReconnect(srv http.Server) http.Server {\n\treturn http.Server{\n\t\tAddr: \":8080\",\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t// ...\n\t\t}),\n\t}\n}\n\ntype graphQLResolvers struct{}\n\ntype graphQLResolver struct{}\n\nfunc initDB() {\n\to := orm.NewOrm()\n\to.Using(\"default\")\n\n\t// Création de la table\n\to.Sync2(new(User))\n}\n\nfunc User() {\n\tO := orm.NewOrm()\n\n\tmodel := User{}\n\n\tmodel.ID = 1\n\tmodel.Name = \"John\"\n\tmodel.Email = \"john@example.com\"\n\n\terr := O.Insert(&model)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\ntype User struct {\n\tID     int    `orm:\"column(id);pk\"`\n\tName   string `orm:\"column(name);\"`\n\tEmail  string `orm:\"column(email);\"`\n\tAddress string `orm:\"column(address);\"`\n}\n\ntype graphQLSchema struct{}\n\nfunc (s *graphQLSchema) Resolve() *schema.Schema {\n\treturn &schema.Schema{\n\t\tQuery: graphql.NewObject(graphql.ObjectConfig{\n\t\t\tName: \"Query\",\n\t\t\tFields: graphql.Fields{\n\t\t\t\t\"hello\": &graphql.Field{\n\t\t\t\t\tType: graphql.String,\n\t\t\t\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\t\treturn \"Hello, world!\", nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t\tMutation: graphql.NewObject(graphql.ObjectConfig{\n\t\t\tName: \"Mutation\",\n\t\t\tFields: graphql.Fields{\n\t\t\t\t\"createUser\": &graphql.Field{\n\t\t\t\t\tType: graphql.String,\n\t\t\t\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\t\t\t\"name\": &graphql.ArgumentConfig{\n\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"email\": &graphql.ArgumentConfig{\n\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\t\tname := p.Args[\"name\"].(string)\n\t\t\t\t\t\temail := p.Args[\"email\"].(string)\n\t\t\t\t\t\to := orm.NewOrm()\n\t\t\t\t\t\tmodel := User{}\n\t\t\t\t\t\tmodel.Name = name\n\t\t\t\t\t\tmodel.Email = email\n\t\t\t\t\t\terr := o.Insert(&model)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"User créé avec succès\", nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t}\n}\n\nfunc initGraphQL() {\n\ts := &graphqlSchema{}\n\tschema := s.Resolve()\n\tgqlgenConfig := gqlgen.NewConfig(schema)\n\tgqlgenConfig.SetSchema(schema)\n\tgqlgenConfig.SetExecutable(\"graphql\")\n\tgqlgenConfig.SetOutputDir(\"internal\")\n\tgqlgenConfig.PrintSchema()\n}\n\nfunc init() {\n}\n", "bugs_introduits": [], "timestamp": 1767006839.5999596}