{"nom_fichier": "main.py", "code": "```python\n# main.py\n\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom typing import Optional\nimport motor.motor_asyncio\nfrom fastapi.responses import JSONResponse\nfrom fastapi import Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.templating import Jinja2Templates\nfrom passlib.context import CryptContext\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom fastapi.security import HTTPBasicCredentials\nfrom fastapi.security import HTTPBasic\nimport json\nfrom fastapi.responses import RedirectResponse\nimport jwt\nfrom fastapi import APIRouter\n\n# Configuration MongoDB\nMONGO_URL = \"mongodb://localhost:27017\"\nMONGO_DB = \"api-rest\"\n\n# Configuration FastAPI\napp = FastAPI(\n    title=\"API REST\",\n    description=\"API REST avec FastAPI et MongoDB\",\n    version=\"1.0\",\n    docs_url=\"/docs\",\n    redoc_url=\"/redoc\",\n)\n\n# Définition des routes\nrouter = APIRouter()\n\n# Configuration de sécurité\nSECRET_KEY = \"my_secret_key\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n# Configuration MongoDB\nclient = motor.motor_asyncio.AsyncIOMotorClient(MONGO_URL)\ndb = client[MONGO_DB]\n# Création d'une collection\ncollection = db[\"Utilisateurs\"]\n\n# Définition du modèle utilisateur\nclass Utilisateur(BaseModel):\n    id: str\n    email: str\n    mot_de_passe: str\n\n# Fonction pour vérifier la validité du mot de passe\ndef verify_password(plain_password, hashed_password):\n    return CryptContext(schemes=[\"bcrypt\"], default=\"bcrypt\").verify(plain_password, hashed_password)\n\n# Fonction pour générer un jeton d'accès\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n# Fonction pour obtenir le jeton d'accès\ndef get_access_token():\n    try:\n        # Récupération du jeton d'accès depuis la session\n        access_token = request.session.get(\"access_token\")\n        return access_token\n    except Exception as e:\n        return None\n\n# Fonction pour valider les informations d'identification\nasync def validate_credentials(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n):\n    # Récupération des utilisateurs depuis la collection\n    utilisateur = collection.find_one({\"email\": credentials.username})\n    if not utilisateur:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Utilisateur non trouvé\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    # Vérification du mot de passe\n    if not verify_password(credentials.password, utilisateur[\"mot_de_passe\"]):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Mot de passe incorrect\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    return utilisateur\n\n# Fonction pour générer un jeton d'accès\nasync def get_current_user(\n    http_authorization_credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer()),\n):\n    # Récupération du jeton d'accès\n    access_token = http_authorization_credentials.credentials\n    try:\n        # Décodage du jeton d'accès\n        data = jwt.decode(access_token, SECRET_KEY, algorithms=[ALGORITHM])\n        utilisateur = collection.find_one({\"id\": data.get(\"id\")})\n        return utilisateur\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Jeton d'accès invalide\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n# Route pour l'inscription\n@app.post(\"/inscription\")\nasync def inscription(utilisateur: Utilisateur):\n    # Création d'un utilisateur\n    utilisateur_dict = utilisateur.dict()\n    utilisateur_dict[\"mot_de_passe\"] = CryptContext(schemes=[\"bcrypt\"], default=\"bcrypt\").hash(utilisateur_dict[\"mot_de_passe\"])\n    collection.insert_one(utilisateur_dict)\n    return {\"message\": \"Utilisateur créé avec succès\"}\n\n# Route pour la connexion\n@app.post(\"/connexion\")\nasync def connexion(utilisateur: Utilisateur):\n    # Vérification des informations d'identification\n    user = await validate_credentials()\n    # Génération d'un jeton d'accès\n    access_token = create_access_token(\n        data={\"sub\": user[\"id\"], \"email\": user[\"email\"]},\n        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES),\n    )\n    return {\"access_token\": access_token}\n\n# Route pour l'API REST\n@app.get(\"/api/{item_id}\")\nasync def read_item(item_id: str, current_user: Utilisateur = Depends(get_current_user)):\n    # Récupération de l'item\n    item = collection.find_one({\"id\": item_id})\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item non trouvé\")\n    return item\n\n# Route pour la documentation Swagger\n@app.get(\"/docs\")\nasync def docs():\n    return {\"message\": \"Documentation Swagger\"}\n\n# Route pour la documentation Redoc\n@app.get(\"/redoc\")\nasync def redoc():\n    return {\"message\": \"Documentation Redoc\"}\n\n# Route pour l'erreur 404\n@app.exception_handler(404)\nasync def http_404_handler(request: Request, exc: Exception):\n    return JSONResponse(content={\"message\": \"Erreur 404\"}, status_code=404)\n\n# Route pour l'erreur 401\n@app.exception_handler(401)\nasync def http_401_handler(request: Request, exc: Exception):\n    return JSONResponse(content={\"message\": \"Erreur 401\"}, status_code=401)\n\n# Route pour l'erreur 500\n@app.exception_handler(500)\nasync def http_500_handler(request: Request, exc: Exception):\n    return JSONResponse(content={\"message\": \"Erreur 500\"}, status_code=500)\n\n# Route pour la page de connexion\n@app.get(\"/connexion\")\nasync def connexion_page():\n    return templates.TemplateResponse(\"connexion.html\", {\"request\": request})\n\n# Route pour la page d'inscription\n@app.get(\"/inscription\")\nasync def inscription_page():\n    return templates.TemplateResponse(\"inscription.html\", {\"request\": request})\n\n# Route pour la page d'API REST\n@app.get(\"/api\")\nasync def api_page():\n    return templates.TemplateResponse(\"api.html\", {\"request\": request})\n\n# Route pour l'erreur 404 de la page de connexion\n@app.exception_handler(404)\nasync def http_404_handler_connexion(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 404</h1>\", status_code=404)\n\n# Route pour l'erreur 401 de la page de connexion\n@app.exception_handler(401)\nasync def http_401_handler_connexion(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 401</h1>\", status_code=401)\n\n# Route pour l'erreur 500 de la page de connexion\n@app.exception_handler(500)\nasync def http_500_handler_connexion(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 500</h1>\", status_code=500)\n\n# Route pour la page de documentation Swagger\n@app.get(\"/docs\")\nasync def docs_page():\n    return templates.TemplateResponse(\"docs.html\", {\"request\": request})\n\n# Route pour la page de documentation Redoc\n@app.get(\"/redoc\")\nasync def redoc_page():\n    return templates.TemplateResponse(\"redoc.html\", {\"request\": request})\n\n# Route pour l'erreur 404 de la page de documentation Swagger\n@app.exception_handler(404)\nasync def http_404_handler_docs(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 404</h1>\", status_code=404)\n\n# Route pour l'erreur 401 de la page de documentation Swagger\n@app.exception_handler(401)\nasync def http_401_handler_docs(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 401</h1>\", status_code=401)\n\n# Route pour l'erreur 500 de la page de documentation Swagger\n@app.exception_handler(500)\nasync def http_500_handler_docs(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 500</h1>\", status_code=500)\n\n# Route pour la page de documentation Redoc\n@app.get(\"/redoc\")\nasync def redoc_page():\n    return templates.TemplateResponse(\"redoc.html\", {\"request\": request})\n\n# Route pour l'erreur 404 de la page de documentation Redoc\n@app.exception_handler(404)\nasync def http_404_handler_redoc(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 404</h1>\", status_code=404)\n\n# Route pour l'erreur 401 de la page de documentation Redoc\n@app.exception_handler(401)\nasync def http_401_handler_redoc(request: Request, exc: Exception):\n    return HTMLResponse(content=\"<h1>Erreur 401</h1>\", status_code=401)\n\n#\n", "langage": "python", "bugs_introduits": [], "corrections_appliquees": [], "timestamp": 1767106981.0278022, "tentative": 1}