{"nom_fichier": "internal/models/models.go", "code": "go\n// Package models définit les modèles de données pour l'application API.\npackage models\n\n// MISSING IMPORT (bug)\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"github.com/lib/pq\"\n\t\"github.com/graphql-go/graphql/gqlerrors\"\n\t\"github.com/jackc/pgtype\"\n\t\"github.com/jackc/pgx/v4\"\n\t\"github.com/jackc/pgx/v4/pgxpool\"\n\n\t\"github.com/go-playground/validator/v10\"\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/graphql-go/graphql/gqlerrors-ext\"\n\t\"github.com/graphql-go/graphql/gqlschema\"\n\t\"github.com/graphql-go/subscriptions/graphqlws\"\n\n\t// jwt \n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// Connexion à la base de données PostgreSQL.\nconst (\n\tDSN = \"user:password@localhost/database\"\n)\n\n// Connexion à la base de données PostgreSQL en utilisant pgx.\nvar (\n\tdbPool *pgxpool.Pool\n)\n\nfunc NewDBPool(ctx context.Context) (*pgxpool.Pool, error) {\n\tpoolConfig, err := pgxpool.ParseConfig(DSN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Crée une connexion à la base de données.\n\tdbPool, err = pgxpool.ConnectConfig(ctx, poolConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn dbPool, nil\n}\n\n// Fonction de validation des données.\nfunc validate(ctx context.Context, obj interface{}) error {\n\terr := validator.New().Struct(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Fonction de gestion des erreurs GraphQL.\nfunc graphqlError(ctx context.Context, err error) graphql.Error {\n\tswitch e := err.(type) {\n\tcase sql.Error:\n\t\tif e.Code() == \"23505\" { // Contrainte d'unicité violée.\n\t\t\treturn graphql.Error{\n\t\t\t\tMessage: \"L'objet existe déjà.\",\n\t\t\t\tFields:  []string{\"id\"}, // Nom de la clé primaire.\n\t\t\t}\n\t\t}\n\tcase pq.Error:\n\t\treturn graphql.Error{\n\t\t\tMessage: e.Message(),\n\t\t}\n\tdefault:\n\t\treturn graphql.Error{\n\t\t\tMessage: \"Une erreur inattendue s'est produite.\",\n\t\t}\n\t}\n}\n\nfunc newGraphQLSchema(schema *gqlschema.Schema, resolvers graphql.ResolverMap) *graphql.ExecutableSchema {\n\treturn graphql.NewSchema(\n\t\tgqlschema.Schema(schema),\n\t\tgraphql.NewExecutorSchema(\n\t\t\tgqlschema.NewSchema(schema),\n\t\t\tresolvers,\n\t\t),\n\t)\n}\n\nfunc getSubscriptionResolvers(schema *gqlschema.Schema, resolvers graphql.ResolverMap) (graphql.ResolverMap, error) {\n\tsubscriptionResolvers := graphql.NewResolverMap()\n\terr := pgxpool.NewPool(DSN).Acquire(func(ctx context.Context, conn *pgx.Conn) error {\n\t\ts, err := graphqlws.NewSubscriptionSrv(conn, schema)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsubscriptionResolvers.Set(\"subscription\", s)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn subscriptionResolvers, nil\n}\n\n// Génère la base de données.\nfunc GenerateDatabase() {\n\tdbPool, err := NewDBPool(context.Background())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Crée les tables de la base de données.\n\t// _, err = dbPool.Exec(`\n\t// \tCREATE TABLE users (\n\t// \t\tid SERIAL PRIMARY KEY,\n\t// \t\tname VARCHAR(255) NOT NULL,\n\t// \t\temail VARCHAR(255) UNIQUE NOT NULL,\n\t// \t\tpassword VARCHAR(255) NOT NULL,\n\t// \t\tcreated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\t// \t\tupdated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n\t// \t);\n\t// \tCREATE TABLE products (\n\t// \t\tid SERIAL PRIMARY KEY,\n\t// \t\tname VARCHAR(255) NOT NULL,\n\t// \t\tdescription TEXT NOT NULL,\n\t// \t\tprice DECIMAL(10, 2) NOT NULL,\n\t// \t\tcreated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\t// \t\tupdated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n\t// \t);\n\t// `)\n\t// if err != nil {\n\t// \tlog.Fatal(err)\n\t// }\n}\n\n// Fonction de vérification de l'authentification.\nfunc VerifyAuthentication(ctx context.Context, token string) (*jwt.Token, error) {\n\t// Récupère le clé secrète de l'application.\n\tsecretKey := []byte(\"SecretKey\") // Régénérer régulièrement cette clé.\n\n\t// Décode le token.\n\ttoken, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"unsupported signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn secretKey, nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn token, nil\n}\n\n// Fonction de récupération de la liste des utilisateurs.\nfunc GetUsers(ctx context.Context) ([]User, error) {\n\tvar users []User\n\n\tq := `\n\t\tSELECT id, name, email, password, created_at, updated_at\n\t\tFROM users;\n\t`\n\n\terr := dbPool.QueryRow(ctx, q).Scan(&users)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn users, nil\n}\n\n// Fonction de récupération d'un utilisateur par son ID.\nfunc GetUser(ctx context.Context, id int) (*User, error) {\n\tvar user User\n\n\tq := `\n\t\tSELECT id, name, email, password, created_at, updated_at\n\t\tFROM users\n\t\tWHERE id = $1;\n\t`\n\n\terr := dbPool.QueryRow(ctx, q, id).Scan(&user.ID, &user.Name, &user.Email, &user.Password, &user.CreatedAt, &user.UpdatedAt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}\n\n// Fonction de création d'un utilisateur.\nfunc CreateUser(ctx context.Context, user User) (*User, error) {\n\t// Vérifie la validité des données.\n\tif err := validate(ctx, &user); err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := `\n\t\tINSERT INTO users (name, email, password, created_at, updated_at)\n\t\tVALUES ($1, $2, $3, NOW(), NOW())\n\t\tRETURNING id, name, email, password, created_at, updated_at;\n  \t`\n\n\tvar newID int\n\tvar newCreatedAt string\n\tvar newUpdatedAt string\n\n\terr := dbPool.QueryRow(ctx, q, user.Name, user.Email, user.Password).Scan(&newID, &user.Name, &user.Email, &user.Password, &newCreatedAt, &newUpdatedAt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser.ID = newID\n\tuser.CreatedAt = newCreatedAt\n\tuser.UpdatedAt = newUpdatedAt\n\n\treturn &user, nil\n}\n\n// Fonction de mise à jour d'un utilisateur.\nfunc UpdateUser(ctx context.Context, id int, user User) (*User, error) {\n\t// Vérifie la validité des données.\n\tif err := validate(ctx, &user); err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := `\n\t\tUPDATE users\n\t\tSET name = $1, email = $2, password = $3, updated_at = NOW()\n\t\tWHERE id = $4;\n\t`\n\n\t_, err := dbPool.Exec(ctx, q, user.Name, user.Email, user.Password, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn GetUser(ctx, id)\n}\n\n// Fonction de suppression d'un utilisateur.\nfunc DeleteUser(ctx context.Context, id int) error {\n\tq := `\n\t\tDELETE FROM users\n\t\tWHERE id = $1;\n\t`\n\n\t_, err := dbPool.Exec(ctx, q, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Type de données utilisateurs.\ntype User struct {\n\tID        int\n\tName      string\n\tEmail     string\n\tPassword  string\n\tCreatedAt string\n\tUpdatedAt string\n}\n\n// Type de données produits.\ntype Product struct {\n\tID        int\n\tName      string\n\tDescription string\n\tPrice     string\n\tCreatedAt string\n\tUpdatedAt string\n}\n\n// Type de données d'erreur GraphQL.\ntype GraphQLError struct {\n\tCode    int    `json:\"code\"`\n\tMessage string `json:\"message\"`\n\tFields  string `json:\"fields\"`\n}\n", "bugs_introduits": ["missing_import", "indentation_error"], "timestamp": 1767006855.2815018}