{"nom_fichier": ".env.example", "code": "go\n// api.go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/jackc/pgx/v4\"\n\t\"github.com/jackc/pgx/v4/pgxpool\"\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/graphql-go/handler\"\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/net/websocket/pkg WebSocketconn\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\n\t\"github.com/graphql-go/graphql-gqlgen\"\n)\n\nvar (\n\tdbpool *pgxpool.Pool\n\tgraphQLSchema *graphql.Schema\n)\n\nfunc main() {\n\t// Configurer la base de données PostgreSQL\n\tvar (\n\t host     = \"localhost\"\n\t\t port     = 5432\n\t\t username = \"postgres\"\n\t\t password = \"password\"\n\t\t dbname   = \"example\"\n\t)\n\tpgxDns := fmt.Sprintf(\"%s %s:%d/%s\", \"user=\" + username, host, port, dbname)\n\n\tpgxpoolConfig, err := pgxpool.ParseConfig(pgxDns)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdbpool, err = pgxpool.ConnectConfig(context.Background(), pgxpoolConfig)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Générer le schéma GraphQL avec Gqlgen\n\ttype User struct {\n\t\tID       string\n\t\tName     string\n\t\tEmail    string\n\t\tPassword string\n\t}\n\n\tgqlgenConfig := &gqlgen.Config{\n\t\tResolvers: &resolvers{\n\t\t\tUser: struct {\n\t\t\t\tGetUser *User\n\t\t\t}{\n\t\t\t\tGetUser: &User{},\n\t\t\t},\n\t\t},\n\t}\n\n\tschema, err := graphql.NewSchema(gqlgenConfig)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgraphQLSchema = schema\n\n\t// Configurer l'authentification JWT\n\tprivateKey := []byte(\"secret_key\")\n\n\tjwtMiddleware := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\ttokenString := r.Header.Get(\"Authorization\")\n\n\t\t\tif tokenString == \"\" {\n\t\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttoken, err := jwt.ParseWithClaims(tokenString, &jwt.MapClaims{\"sub\": r.URL.Path}, func(token *jwt.Token) (interface{}, error) {\n\t\t\t\treturn privateKey, nil\n\t\t\t})\n\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !token.Valid {\n\t\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\t// Configurer les websockets\n\twsUpgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\n\thttp.HandleFunc(\"/graphql\", graphqlHandler)\n\n\thttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\tws, err := wsUpgrader.Upgrade(w, r, nil)\n\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tdefer ws.Close()\n\n\t\twsHandler(ws)\n\t})\n\n\thttp.HandleFunc(\"/connect\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\n\t\ttoken, err := jwt.ParseWithClaims(tokenString, &jwt.MapClaims{\"sub\": r.URL.Path}, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn privateKey, nil\n\t\t})\n\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !token.Valid {\n\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(\"Connected\"))\n\t})\n\n\thttp.HandleFunc(\"/ping\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Pong\"))\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", jwtMiddleware(http.DefaultServeMux)))\n}\n\nfunc graphqlHandler(w http.ResponseWriter, r *http.Request) {\n\t// Gérer les requêtes GraphQL\n\th := handler.New(&handler.Options{\n\t\tSchema:       graphQLSchema,\n\t\tGraphiQL:     true,\n\t\tPlayground:   true,\n\t\tAutoCyles:    true,\n\t})\n\n\tres := h.ServeHTTP(w, r)\n\n\tswitch res.StatusCode {\n\tcase http.StatusOK:\n\t\tw.Write(res.Body)\n\tcase http.StatusUnauthorized:\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\tdefault:\n\t\tw.WriteHeader(res.StatusCode)\n\t\tw.Write(res.Body)\n\t}\n}\n\nfunc wsHandler(ws *websocket.Conn) {\n\t// Gérer les websockets\n\t// ...\n\n\tws.Close()\n}\n\ntype resolvers struct{}\n\ntype User struct {\n\tID       string\n\tName     string\n\tEmail    string\n\tPassword string\n}\n", "bugs_introduits": [], "timestamp": 1767006863.232921}