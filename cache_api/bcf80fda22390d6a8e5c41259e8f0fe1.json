{"nom_fichier": "main.go", "code": "go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/lib/pq\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/redis/go-redis/v9\"\n)\n\n// User represent a user\ntype User struct {\n\tID       uint   `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\n// Database represents a PostgreSQL database\ntype Database struct {\n\t*sql.DB\n}\n\n// NewDatabase returns a new Database instance\nfunc NewDatabase(dsn string) (*Database, error) {\n\tdb, err := sql.Open(\"postgres\", dsn)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to open database\")\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, errors.Wrap(err, \"ping database failed\")\n\t}\n\n\treturn &Database{DB: db}, nil\n}\n\n// Redis represents a Redis client\ntype Redis struct {\n\t*redis.Client\n}\n\n// NewRedis returns a new Redis instance\nfunc NewRedis(addr string) (*Redis, error) {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     addr,\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\tif _, err := client.Ping(context.Background()).Result(); err != nil {\n\t\treturn nil, errors.Wrap(err, \"ping Redis failed\")\n\t}\n\n\treturn &Redis{Client: client}, nil\n}\n\n// GenerateKey generates a random key\nfunc GenerateKey() (string, error) {\n\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"failed to generate key\")\n\t}\n\n\treturn fmt.Sprintf(\"%x\", privateKey.PublicKey.N), nil\n}\n\n// UserHandler handles user-related requests\ntype UserHandler struct {\n\tdb  *Database\n\tredis *Redis\n}\n\n// NewUserHandler returns a new UserHandler instance\nfunc NewUserHandler(db *Database, redis *Redis) *UserHandler {\n\treturn &UserHandler{db: db, redis: redis}\n}\n\nfunc (u *UserHandler) Register(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\tif err := json.NewDecoder(r.Body).Decode(&user); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif _, err := u.db.Exec(\"INSERT INTO users (username, password) VALUES ($1, $2)\", user.Username, user.Password); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tkey, err := GenerateKey()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tu.redis.Set(context.Background(), fmt.Sprintf(\"user:%d\", user.ID), key, 0)\n\tu.redis.Set(context.Background(), fmt.Sprintf(\"user:%s\", user.Username), key, 0)\n\n\tw.WriteHeader(http.StatusCreated)\n}\n\nfunc (u *UserHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\tif err := json.NewDecoder(r.Body).Decode(&user); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar storedKey string\n\tif storedKey, err = u.redis.Get(context.Background(), fmt.Sprintf(\"user:%s\", user.Username)).Result(); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tif err := u.db.QueryRow(\"SELECT password FROM users WHERE username = $1\", user.Username).Scan(&user.Password); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tif user.Password != storedKey {\n\t\thttp.Error(w, \"invalid password\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc main() {\n\tdsn := \"user:password@localhost/mydatabase\"\n\taddr := \"localhost:6379\"\n\n\tdb, err := NewDatabase(dsn)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tredis, err := NewRedis(addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\trouter := mux.NewRouter()\n\n\tuserHandler := NewUserHandler(db, redis)\n\n\trouter.HandleFunc(\"/register\", userHandler.Register).Methods(\"POST\")\n\trouter.HandleFunc(\"/login\", userHandler.Login).Methods(\"POST\")\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", router))\n}\n", "timestamp": 1766868109.6344624}