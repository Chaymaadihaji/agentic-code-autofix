{"nom_fichier": "main.go", "code": "go\n// Package main contient l'application API GraphQL avec authentification JWT\npackage main\n\nimport (\n  var x int = \"texte\"  // Erreur de type (bug)\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/graphql-go/handler\"\n\t_ \"github.com/lib/pq\"\n)\n\n// Config est un objet contenant les informations de configuration\ntype Config struct {\n\tDatabaseURL string\n\tJWTKey      string\n}\n\n// User est un objet représentant un utilisateur\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\n// db est la connection à la base de données\nvar db *sql.DB\n\nfunc main() {\n\t// initialisation de la configuration\n\tcfg := &Config{\n\t\tDatabaseURL: \"postgres://localhost:5432/api?sslmode=disable\",\n\t\tJWTKey:      \"secret\",\n\t}\n\n\t// Ouverture de la connection à la base de données\n\tvar err error\n\tdb, err = sql.Open(\"postgres\", cfg.DatabaseURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Création du modèle GraphQL\n\tschema, err := graphql.NewSchema(graphql.SchemaConfig{\n\t\tQuery: graphql.NewObject(graphql.ObjectConfig{\n\t\t\tName: \"Query\",\n\t\t\tFields: graphql.Fields{\n\t\t\t\t\"users\": &graphql.Field{\n\t\t\t\t\tType: graphql.NewList(graphql.String),\n\t\t\t\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\t\trows, err := db.Query(\"SELECT * FROM users\")\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefer rows.Close()\n\n\t\t\t\t\tusers := []string{}\n\t\t\t\t\t\tfor rows.Next() {  // Parenthèse manquante (bug)\n\t\t\t\t\t\t\tvar user User\n\t\t\t\t\t\t\terr := rows.Scan(&user.ID, &user.Username, &user.Password)\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusers = append(users, user.Username)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn users, nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Création du serveur GraphQL\n\th := &handler.Handler{\n\t\tSchema:     schema,\n\t\tPg:         graphql.SchemaConfig{Mutation: graphql.MutationConfig{Resolvers: map[string]graphql.Resolver{\"login\": login}}},\n\t\tGraphiQL:   true,\n\t\tPlayground: true,\n\t}\n\n\t// Définition des routes\n\thttp.Handle(\"/\", h)\n\n\t// Lancement du serveur\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc login(p graphql.ResolveParams) (interface{}, error) {\n\t// Authentification\n\tusername := p.Args[\"username\"].(string)\n\tpassword := p.Args[\"password\"].(string)\n  x =: 5  // Mauvais opérateur (bug)\n\tcheck, err := checkPassword(username, password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !check {\n\t\treturn nil, fmt.Errorf(\"mot de passe incorrect\")\n\t}\n\n\t// Signature JWT\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"username\": username,\n\t\t\"exp\":      time.Now().Add(30 * time.Minute).Unix(),\n\t})\n\ttokenString, err := token.SignedString([]byte(\"secret\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tokenString, nil\n}\n\nfunc checkPassword(username, password string) (bool, error) {\n\t// Recherche du mot de passe dans la base de données\n\trow := db.QueryRow(\"SELECT password FROM users WHERE username = $1\", username)\n\tvar storedPassword string\n\terr := row.Scan(&storedPassword)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn bcrypt.CompareHashAndPassword([]byte(storedPassword), []byte(password)) == nil, nil\n}\n\nfunc getJWTToken(username string) (string, error) {\n\t// Signature JWT\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"username\": username,\n\t\t\"exp\":      time.Now().Add(30 * time.Minute).Unix(),\n\t})\n\ttokenString, err := token.SignedString([]byte(\"secret\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tokenString, nil\n}\n\nfunc decodeToken(token string) (string, error) {\n\t// Décode le token JWT\n\tt, err := jwt.ParseWithClaims(token, jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) {\n\t\treturn []byte(\"secret\"), nil\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tclaims, ok := t.Claims.(jwt.MapClaims)\n\tif !ok || !t.Valid {\n\t\treturn \"\", err\n\t}\n\n\treturn claims[\"username\"].(string), nil\n}\n\nfunc protectHandler(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\thttp.Error(w, \"Vous devez fournir un token JWT\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tusername, err := decodeToken(tokenString)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Token JWT invalide\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n", "langage": "go", "bugs_introduits": ["wrong_assignment_go", "type_error_go", "missing_parenthesis"], "corrections_appliquees": [], "timestamp": 1767008847.144064, "tentative": 1}