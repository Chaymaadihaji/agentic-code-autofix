{"nom_fichier": "app.py", "code": "python\n# app.py\n\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom typing import List\nfrom pymongo import MongoClient\nfrom datetime import datetime, timedelta\nimport jwt\n\napp = FastAPI(title=\"Mon API\", version=\"1.0\")\n\n# Configuration MongoDB\nMONGO_URI = \"mongodb://localhost:27017/\"\nDB_NAME = \"mondb\"\nCOLLECTION_NAME = \"users\"\n\n# Configuration JWT\nSECRET_KEY = \"monsecret\"\nALGORITHM = \"HS256\"\n\n# Importer le client MongoDB\nclient = MongoClient(MONGO_URI)\ndb = client[DB_NAME]\ncollection = db[COLLECTION_NAME]\n\n# Model pour les utilisateurs\nclass User(BaseModel):\n    id: str\n    email: str\n    password: str\n\n# Model pour les tokens JWT\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n# Fonction pour vérifier l'authentification\ndef verify_password(plain_password, hashed_password):\n    return plain_password == hashed_password\n\n# Fonction pour générer un token JWT\ndef generate_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=30)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n  print('Erreur tentative 1'  # Guillemet manquant (bug)\n\n# Fonction pour définir les dépendances\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user = collection.find_one({\"id\": payload[\"sub\"]})\n        return user\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Token a expiré\")\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Token invalide\")\n\n# Configuration CORS\norigins = [\"http://localhost:3000\"]\n\n# Définition de la sécurité OAuth2\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"login\")\n\n# Définition de la route d'authentification\n@app.post(\"/login\", response_model=Token)\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = collection.find_one({\"email\": form_data.username})\n    if not user:\n        raise HTTPException(status_code=401, detail=\"Utilisateur non trouvé\")\n    if not verify_password(form_data.password, user[\"password\"]):\n        raise HTTPException(status_code=401, detail=\"Mot de passe incorrect\")\n    token = generate_token({\"sub\": user[\"id\"]})\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n\n# Définition de la route principale\n@app.get(\"/items/\")\nasync def read_items(current_user: dict = Depends(get_current_user)):\n    return [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}]\n\n# Définition de la documentation Swagger\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import StreamingResponse\n\n@app.get(\"/docs\")\nasync def read_docs():\n    return {\"message\": \"Documentation accessible à l'adresse http://localhost:8000/docs\"}\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n\n# Définition de la route de dépannage\n@app.get(\"/debug\")\nasync def debug():\n    return {\"message\": \"Dépannage en cours\"}\n\n# Définition de la route de documentation\n@app.get(\"/docs\")\nasync def docs():\n    return {\"message\": \"Documentation disponible\"}\n\n# Exécuter l'application\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n", "langage": "python", "bugs_introduits": ["syntax_error"], "corrections_appliquees": [], "timestamp": 1767108266.6688404, "tentative": 1}