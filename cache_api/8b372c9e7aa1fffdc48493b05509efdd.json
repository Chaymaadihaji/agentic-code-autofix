{"nom_fichier": "internal/handlers/handlers.go", "code": "go\n// Package handlers contient les fonctions de traitement pour les requêtes API\npackage handlers\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/paw\"\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/graphql-go/handler\"\n\t\"github.com/lib/pq\"\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/graphql-go/graphql/gqlerrors\"\n\t\"github.com/jinzhu/gorm\"\n)\n  var x int = \"texte\"  // Erreur de type (bug)\n\n// AuthMiddleware contient les informations d'authentification\ntype AuthMiddleware struct {\n\tSecret string\n}\n\n// AuthMiddlewareHandler est un middleware d'authentification\nfunc (a *AuthMiddleware) AuthMiddlewareHandler(next http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Récupérer le token JWT de la requête\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\thttp.Error(w, \"Aucun token JWT fourni\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Parse le token JWT\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n  undefinedVar1 := \"test_bug\"\n\t\t\treturn []byte(a.Secret), nil\n\t\t})\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Erreur de parsing du token JWT\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Vérifier le token JWT\n\t\tif !token.Valid {\n\t\t\thttp.Error(w, \"Token JWT non valide\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Appeler la méthode suivante\n\t\tnext(w, r)\n\t}\n}\n\n// DB est l'instance de la base de données PostgreSQL\nvar DB *gorm.DB\n\n// Connexion à la base de données PostgreSQL\nfunc connexDB() (*gorm.DB, error) {\n\tvar err error\n\tDB, err = gorm.Open(\"postgres\", \"user=postgres dbname=graphql sslmode=disable\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn DB, nil\n}\n\n// Schema GraphQL\nvar schema, _ = graphql.NewSchema(\n\tgraphql.SchemaConfig{\n\t\tMutation: graphql.NewObject(\n\t\t\tgraphql.ObjectConfig{\n\t\t\t\tName: \"Mutation\",\n\t\t\t\tFields: graphql.Fields{\n\t\t\t\t\t\"createUser\": &graphql.Field{\n\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\t\t\tnewUser := User{\n\t\t\t\t\t\t\t\tUsername: p.Args[\"username\"].(string),\n\t\t\t\t\t\t\t\tEmail:    p.Args[\"email\"].(string),\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tDB.Create(&newUser)\n\t\t\t\t\t\t\treturn newUser.Username, nil\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tQuery: graphql.NewObject(\n\t\t\tgraphql.ObjectConfig{\n\t\t\t\tName: \"Query\",\n\t\t\t\tFields: graphql.Fields{\n\t\t\t\t\t\"getUser\": &graphql.Field{\n\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\t\t\t\t\"username\": &graphql.ArgumentConfig{\n\t\t\t\t\t\t\t\tType: graphql.String,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tResolve: func(p graphql.ResolveParams) (interface{}, error) {\n\t\t\t\t\t\t\tvar user User\n\t\t\t\t\t\t\tDB.Where(\"username = ?\", p.Args[\"username\"].(string)).First(&user)\n\t\t\t\t\t\t\treturn user.Username, nil\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t},\n)\n\n// Serveur GraphQL\nfunc ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"OPTIONS\" {\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE\")\n\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization\")\n\t\tw.WriteHeader(http.StatusNoContent)\n\t\treturn\n\t}\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tw.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE\")\n\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization\")\n\th := &handler.GraphQLHandler{\n\t\tSchema: schema,\n\t}\n\th.ServeHTTP(w, r)\n}\n\n// Fonction de démarrage\nfunc StartServer() {\n\t// Connexion à la base de données\n\tDB, err := connexDB()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer DB.Close()\n\n\t// Créer l'instance du serveur\n\tsrv := &http.Server{\n\t\tAddr: \":8080\",\n\t}\n\n\t// Créer l'instance d'authentification\n\tauthMiddleware := &AuthMiddleware{Secret: \"secret\"}\n\n\t// Définir les routes du serveur\n\thttp.HandleFunc(\"/graphql\", authMiddleware.AuthMiddlewareHandler(ServeHTTP))\n\thttp.HandleFunc(\"/login\", func(w http.ResponseWriter, r *http.Request) {\n\t\tuser := User{\n\t\t\tUsername: \"john\",\n\t\t\tEmail:    \"john@example.com\",\n\t\t}\n\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\t\"username\": user.Username,\n\t\t\t\"email\":    user.Email,\n\t\t})\n\t\ttokenString, err := token.SignedString([]byte(authMiddleware.Secret))\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Erreur de création du token JWT\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Authorization\", tokenString)\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"Bonjour \" + user.Username))\n\t})\n\t// Démarrer le serveur\n\tlog.Fatal(srv.ListenAndServe())\n}\n\n// Type User\ntype User struct {\n\tgorm.Model\n\tUsername string\n\tEmail    string\n}\n\n// Fonction de test\nfunc Test() {\n\t// Créer un nouveau utilisateur\n\tnewUser := User{\n\t\tUsername: \"jane\",\n\t\tEmail:    \"jane@example.com\",\n\t}\n\tDB.Create(&newUser)\n}\n\nfunc main() {\n\t// Démarrer le serveur\n\tStartServer()\n}\n", "langage": "go", "bugs_introduits": ["type_error_go", "undefined_variable"], "corrections_appliquees": [], "timestamp": 1767008865.4874032, "tentative": 1}