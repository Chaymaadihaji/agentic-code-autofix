{"nom_fichier": "internal/handlers/handlers.go", "code": "go\n// Package handlers contient les fonctions de traitement des requêtes API\npackage handlers\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"golang.org/x/crypto/bcrypt\"\n\t\"internal/database\"\n\t\"internal/graphql/generated\"\n\t\"internal/util\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/graphql-go/graphql-go/errors\"\n)\n\nconst (\n\tsecretKey = \"secretKey\"\n)\n\n// generateToken renvoie un token JWT généré\nfunc generateToken(user *database.User) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"username\": user.Username,\n\t\t\"exp\":      time.Now().Add(time.Hour * 72).Unix(),\n\t})\n\treturn token.SignedString([]byte(secretKey))\n}\n\n// authenticateUser vérifie les informations d'identification de l'utilisateur\nfunc authenticateUser(ctx context.Context, r *http.Request) (*database.User, error) {\n\tvars := mux.Vars(r)\n\ttokenString := vars[\"token\"]\n\n\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\treturn []byte(secretKey), nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\tusername, ok := claims[\"username\"].(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"erreur au cours de l'authentification\")\n\t\t}\n\t\treturn database.GetUserByUsername(ctx, username)\n\t} else {\n\t\treturn nil, errors.Errorf(\"token non valide\")\n\t}\n}\n\n// GetHandler retourne une fonction qui traite les requêtes GET\nfunc GetHandler() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tswitch r.URL.Path {\n\t\tcase \"/\":\n\t\t\tgeneratedSchema := generated.GetSchema()\n\t\t\tgeneratedSchema.SetQuery(\n\t\t\t\tgenerated.Field(\n\t\t\t\t\t\"query\",\n\t\t\t\t\t\"Query\",\n\t\t\t\t\tgenerated.String(),\n\t\t\t\t\t\"Retourne une chaîne de caractères\",\n\t\t\t\t),\n\t\t\t)\n\t\t\tfmt.Fprint(w, generatedSchema)\n\t\tcase \"/graphql\":\n\t\t\tgeneratedSchema := generated.GetSchema()\n\t\t\tgeneratedSchema.SetQuery(\n\t\t\t\tgenerated.Field(\n\t\t\t\t\t\"query\",\n\t\t\t\t\t\"Query\",\n\t\t\t\t\tgenerated.String(),\n\t\t\t\t\t\"Retourne une chaîne de caractères\",\n\t\t\t\t),\n\t\t\t)\n\t\t\tgeneratedSchema.Mutate(\n\t\t\t\tgenerated.Field(\n\t\t\t\t\t\"mutation\",\n\t\t\t\t\t\"Mutation\",\n\t\t\t\t\tgenerated.String(),\n\t\t\t\t\t\"Modifie une chaîne de caractères\",\n\t\t\t\t),\n\t\t\t)\n\t\t\tgeneratedSchema.Subscription(\n\t\t\t\tgenerated.Field(\n\t\t\t\t\t\"subscription\",\n\t\t\t\t\t\"Subscription\",\n\t\t\t\t\tgenerated.String(),\n\t\t\t\t\t\"Envoie une chaîne de caractères\",\n\t\t\t\t),\n\t\t\t)\n\t\t\tgeneratedContext := generated.NewContext(r.Context())\n\t\t\terr := generatedContext.Run(r.Context(), w, r.URL.Path, generatedSchema)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprint(w, err.Error())\n\t\t\t}\n\t\tdefault:\n\t\t\thttp.NotFound(w, r)\n\t\t}\n\t}\n}\n\n// SignupHandler retourne une fonction qui traite les requêtes POST pour la création d'utilisateur\nfunc SignupHandler() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n  fmt.Println(\"Erreur tentative 2\"  // Parenthèse manquante (bug)\n\t\tvars := mux.Vars(r)\n\t\tusername := vars[\"username\"]\n\t\tpassword := vars[\"password\"]\n\n\t\thash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\tfmt.Fprint(w, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tuser := database.NewUser(username, string(hash))\n\n\t\terr = database.CreateUser(r.Context(), user)\n\t\tif err != nil {\n\t\t\tfmt.Fprint(w, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tuser, err = database.GetUserByUsername(r.Context(), username)\n\t\tif err != nil {\n\t\t\tfmt.Fprint(w, err.Error())\n\t\t\treturn\n  var x int = \"texte\"  // Erreur de type (bug)\n\t\t}\n\n\t\ttoken, err := generateToken(user)\n\t\tif err != nil {\n\t\t\tfmt.Fprint(w, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprint(w, token)\n\t}\n}\n\n// LoginHandler retourne une fonction qui traite les requêtes POST pour la connexion d'utilisateur\nfunc LoginHandler() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvars := mux.Vars(r)\n\t\tusername := vars[\"username\"]\n\t\tpassword := vars[\"password\"]\n\n\t\tuser, err := database.GetUserByUsername(r.Context(), username)\n\t\tif err != nil {\n\t\t\tfmt.Fprint(w, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\terr = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))\n\t\tif err != nil {\n\t\t\tfmt.Fprint(w, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\ttoken, err := generateToken(user)\n\t\tif err != nil {\n\t\t\tfmt.Fprint(w, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprint(w, token)\n\t}\n}\n", "langage": "go", "bugs_introduits": ["syntax_error", "type_error_go"], "corrections_appliquees": [], "timestamp": 1767008551.3129075, "tentative": 2}