{"nom_fichier": "main.go", "code": "go\n// main.go\n\n// Package et versió\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/relay\"\n\t\"github.com/lib/pq\"\n\t\"github.com/urfave/negroni\"\n\n\t// Importer l'ajout de middleware\n\t_ \"github.com/2meter/auth-middleware\"\n)\n\n// Modelles de données\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\n// Générateur du schéma GraphQL\ntype Resolver struct{}\n\nfunc (r *Resolver) Query() graphql.Object {\n\treturn &queryResolver{r}\n}\n\nfunc (r *Resolver) Mutation() graphql.Object {\n\treturn &mutationResolver{r}\n}\n\nfunc (r *Resolver) Subscription() graphql.Object {\n\treturn &subscriptionResolver{r}\n}\n\ntype queryResolver struct{ *Resolver }\ntype mutationResolver struct{ *Resolver }\ntype subscriptionResolver struct{ *Resolver }\n\n// Query\nfunc (r *queryResolver) Users(ctx context.Context) (*graphql.ExecutionResult, error) {\n\treturn &graphql.ExecutionResult{\n\t\tData: map[string]interface{}{\n\t\t\t\"users\": []map[string]string{\n\t\t\t\t{\n\t\t\t\t\t\"id\":       \"1\",\n\t\t\t\t\t\"username\": \"John\",\n\t\t\t\t\t\"email\":    \"john@example.com\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\":       \"2\",\n\t\t\t\t\t\"username\": \"Jane\",\n\t\t\t\t\t\"email\":    \"jane@example.com\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Mutation\nfunc (r *mutationResolver) Login(ctx context.Context, input *LoginInput) (*graphql.ExecutionResult, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"email\": input.Email,\n\t})\n\ttokenString, err := token.SignedString([]byte(\"secret\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &graphql.ExecutionResult{\n\t\tData: map[string]interface{}{\n\t\t\t\"token\": tokenString,\n\t\t},\n\t}, nil\n}\n\n// Subscription\nfunc (r *subscriptionResolver) newUser(ctx context.Context) (*graphql.ExecutionResult, error) {\n\treturn &graphql.ExecutionResult{\n\t\tData: map[string]interface{}{\n\t\t\t\"newUser\": map[string]string{\n\t\t\t\t\"id\":       \"3\",\n\t\t\t\t\"username\": \"Bob\",\n\t\t\t\t\"email\":    \"bob@example.com\",\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Connexion à la base de données\nfunc main() {\n\tpsqlInfo := fmt.Sprintf(\"host=localhost user=postgres dbname=users sslmode=disable\")\n\n\t// Ouverture de la base de données\n\tdb, err := pq.Open(psqlInfo)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Initialisation de Gqlgen\n\t// Générer le schéma GraphQL\n\tgq := graphql.Schema{\n\t\tQuery: &queryResolver{},\n\t\tMutation: &mutationResolver{},\n\t\tSubscription: &subscriptionResolver{},\n\t}\n\n\t// Initialisation de JWT\n\tmw := negroni.New(\n\t\tnegroni.NewRecover(),\n\t\tnegroni.NewLogger(),\n\t\t// Ajout du middleware d'authentification\n\t\tnegroni.NewMiddlewareWithFunc(authMiddleware),\n\t)\n\n\t// Démarrage du serveur\n\tfmt.Println(\"Server démarré sur le port 8080\")\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", mw.Serve(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Error(w, \"Not implemented\", http.StatusNotImplemented)\n\t}))))\n}\n\n// Middle-ware pour authentication\nfunc authMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\thttp.Error(w, \"Authorization Header manquant\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn []byte(\"secret\"), nil\n\t\t})\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Erreur lors de la verification du token: \"+err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tif !token.Valid {\n\t\t\thttp.Error(w, \"Token Expédité: \"+token.String(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\ntype LoginInput struct {\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n}\n", "langage": "go", "bugs_introduits": [], "corrections_appliquees": [], "timestamp": 1767009019.1861353, "tentative": 4}