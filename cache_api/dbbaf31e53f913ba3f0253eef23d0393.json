{"nom_fichier": "models.py", "code": "python\n# models.py\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom fastapi.security import OAuth2PasswordBearer\nfrom passlib.context import CryptContext\n\n# Configuration pour l'authentification\nSECRET_KEY = \"c0a3f0c2a1a3a0a1c3c2a0a1c3e0\"\nSECRET_ALGORITHM = \"HS256\"\nJWT_SECRET_KEY = \"f0c2a1a3a1c3e0c2a0a1a3c2e3d2a\"\nJWT_ALGORITHM = \"HS256\"\nCORS_ORIGINS = [\"*\"]\nCORS_ALLOW_METHODS = [\"*\"]\nCORS_ALLOW_HEADERS = [\"*\"]\nCORS_EXPOSE_HEADERS = [\"*\"]\n\n# Configuration pour MongoDB\nMONGODB_URL = \"mongodb://localhost:27017\"\nMONGODB_DB = \"entreprise\"\n\n# Configuration pour l'authentification\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\nclass Utilisateur(BaseModel):\n    username: str\n    email: str\n    password: str\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], default=\"bcrypt\")\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"\n    Fonction pour hacher le mot de passe\n    \"\"\"\n    return pwd_context.hash(password)\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Fonction pour vérifier la validité du mot de passe\n    \"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\nasync def get_user(db, username: str):\n    \"\"\"\n    Fonction pour récupérer un utilisateur\n    \"\"\"\n    user = await db[\"utilisateurs\"].find_one({\"username\": username})\n    return user\n\nasync def get_user_by_email(db, email: str):\n    \"\"\"\n    Fonction pour récupérer un utilisateur par email\n    \"\"\"\n    user = await db[\"utilisateurs\"].find_one({\"email\": email})\n    return user\n\nasync def authenticate_user(db, username: str, password: str):\n    \"\"\"\n    Fonction pour authentifier un utilisateur\n    \"\"\"\n    user = await get_user(db, username)\n    if not user:\n        return False\n    if not verify_password(password, user[\"password\"]):\n        return False\n    return user\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"\n    Fonction pour créer un jeton d'accès\n    \"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)\n    return encoded_jwt\n\ndef get_token(data: dict):\n    \"\"\"\n    Fonction pour récupérer un jeton d'accès\n    \"\"\"\n    token = create_access_token(data, expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n", "langage": "python", "bugs_introduits": [], "corrections_appliquees": [], "timestamp": 1767108336.9041905, "tentative": 2}